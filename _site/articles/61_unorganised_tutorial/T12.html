<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Kernel: Basic Concepts Part 1 | BrokenThorn OS Dev Tutorials </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Kernel: Basic Concepts Part 1 | BrokenThorn OS Dev Tutorials ">
    <meta name="generator" content="docfx 2.56.1.0">
    
    <link rel="shortcut icon" href="../../resources/icons/favicon.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="../toc.html">
    
    <meta property="docfx:rel" content="../../">
    <meta property="docfx:newtab" content="true">
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../resources/images/favicon.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list"></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="kernel-basic-concepts-part-1">Kernel: Basic Concepts Part 1</h1>

<p>The Kernel is the Core of all operating systems. Understanding what it is and how it effects the operating system is important.</p>
<p>In this tutorial, We will look at what goes behind Kernels, what they are, and what they are responsible for. Understanding these concepts is essential in coming up with a good design.</p>
<h2 id="kernel-basic-definition">Kernel: Basic Definition</h2>
<p>In order to understand what an OS <strong>Kernel</strong> is, we need to first understand what a <strong>&quot;kernel&quot;</strong> is at it's basic definitions. Dictionaries define &quot;kernel&quot; as &quot;core&quot;, &quot;essential part&quot;, or even &quot;The body of something&quot;. When applying this definition to an Operating System environment, we can easily state that:</p>
<p><strong>The Kernel is the core component of an operating system.</strong></p>
<p>Okay, but what does this mean for us? What exactly is an OS Kernel, and why should we care for it?</p>
<p>There is no rule that states a kernel is mandatory. We can easily just load and execute programs at specific addresses without any &quot;kernel&quot;. In fact, all of the early computer systems started this way. Some modern systems also use this. A notable example of this are the early console video game systems, which required <strong>rebooting</strong> the system in order to execute <strong>one</strong> of the games designed for that console.</p>
<p>So, what is the point of a Kernel? In a computing environment, it is impractical to restart every time to execute a program. This will means that each program itself would need its own bootloaders and direct hardware controlling. After all, if the programs need to be executed at bootup, there would be no such thing as an operating system.</p>
<p>What we need is an abstraction layer to provide the capability of executing multiple programs, and manage their memory allocations. It also can provide an abstraction to the hardware, which will not be possible if each program had to start on bootup without an OS. After all, the software will be running on raw hardware.</p>
<p>The keyword here is <strong>Abstraction</strong>. Lets look closer...</p>
<h2 id="the-need-for-kernels">The need for Kernels</h2>
<p>The Kernel provides the primary abstraction layer to the hardware itself. The Kernel is usually at Ring 0 because of this very reason: <strong>It has direct control over every little thing</strong>. Because we are still at Ring 0, we already experienced this.</p>
<p>This is good--but what about other software? Remember that we are developing an <strong>operating environment</strong>? Our primary goal is providing a safe, and effective environment for applications and other software to execute. If we let all software to run at Ring 0, alongside the Kernel, there would be no need for a kernel, would there be? If there was, <strong>The ring 0 software may conflict with the ring 0 Kernel</strong>, causing unpredictable results. After all, they all have complete control over every byte in the system. Any software can overwrite the kernel, or any other software without any problems. Ouch.</p>
<p>Yet, that is only the beginning of the problems. It is impossible to have multitasking, or multiprocessing as there is no common ground to switch between programs and processes. Only one program can execute at a time.</p>
<p>The basic idea is that a Kernel is a necessity. Not only do we want to <strong>prevent</strong> other software direct control over everything, but we want to create an <strong>abstraction layer</strong> for it.</p>
<p>Understanding where and how the Kernel fits in with the rest of the system is very important.</p>
<h2 id="abstraction-layers-of-software">Abstraction Layers of Software</h2>
<p>Software has a lot of abstractions. All of these abstractions is meant to provide a core and basic interfaces to not only hide implementation detail, but to <strong>shield</strong> you from it. Having direct control over everything might seem cool--but imagine how much problems would be caused by doing this.</p>
<p>You might be curious as of what problems I am referring to. Remember that, it its core, electronics does only what we tell it. We can control the software down to the <strong>hardware</strong> level, and in some cases, <strong>electronics</strong> level. Making a mistake at these levels can physically cause damage to those devices.</p>
<p>Lets take a look at each abstraction layer to understand what I mean, and to see where our Kernel fits in.</p>
<h3 id="relationship-with-pmode-protection-ring-levels">Relationship with PMode Protection Ring Levels</h3>
<p>In <strong>Bootloaders 3 Tutorial</strong>, we have took a detailed look at the Rings of Assembly Language. We also looked at how this related to <strong>protected mode</strong>.</p>
<p>Remember that <strong>Ring 0 software has the lowest protection level.</strong> This means that we have direct control over everything, and are <strong>expected</strong> to never crash. If <strong>any</strong> Ring 0 program was to crash, it will take the system down with it (Triple Fault).</p>
<p>Because of this, not only do we want to <strong>shield</strong> everything else from direct control, but we want to only give software the protection level needed to run it. Because of this, normally:</p>
<ul>
<li>Kernels work in Ring 0 (&quot;Supervisor Mode&quot;)</li>
<li>Device Drivers work in Rings 1 and 2, as they require direct access to hardware devices</li>
<li>Normal application software work in Ring 3 (&quot;User Mode&quot;)</li>
</ul>
<p>Okay... <strong>how</strong> does this all fit together? Lets take a closer look...</p>
<h3 id="level-1-hardware-level">Level 1: Hardware Level</h3>
<p>This is the actual physical component. The actual microcontroller chips on the motherboard. They send low level commands to other microcontrollers on other devices that physically control this device. How? We will look at that in Level 2.</p>
<p>Examples of hardware are the microcontroller chipset (The &quot;Motherboard Chipset'), disk drives, SATA, IDE, hard drives, memory, the processor (Which is also a controller--Please see Level 2 more more information).</p>
<p>This is the lowest level, and the most detailed as it is pure electronics.</p>
<h3 id="level-2-firmware-level">Level 2: Firmware Level</h3>
<p>The Firmware sets on top of the electronics level. It contains the software needed by each hardware device and microcontroller. One example of firmware is the BIOS POST.</p>
<p>Remember the processor itself is nothing more then a controller--and just like other controllers, rely on its firmware. The <strong>Instruction Decoder</strong> within the processor dissects a single machine instruction into either <strong>Macrocode</strong>, or directly to <strong>Microcode</strong>.</p>
<p>Please see the <strong>Tutorial 7: System Architecture Tutorial</strong> for more information.</p>
<h4 id="microcode">Microcode</h4>
<p>Firmware is usually developed using microcode, and either assembled (With a microassembler) and uploaded into a storage area (Such as the BIOS POST), or hardwired into the logic circuits of the device through various of means.</p>
<p>Microcode is usually stored within a ROM chip, such as EEPROM.</p>
<p>Microcode is very hardware specific. Whenever there is a new change or revision, a new Microcode instruction set and Micro assembler needs to be developed. On some systems, Microcode has been used to control individual electronic gates and switches within the circuit. Yes, It is that low level.</p>
<h4 id="macrocode">Macrocode</h4>
<p>Microcode is <strong>very</strong> low level, and can be <strong>very</strong> hard to develop with, especially in complex systems, such as a microprocessor or CPU. It also must be reimplemented whenever a change happens--Not only the code, but the Microprograms as well.</p>
<p>Because of this, some systems have implemented a more higher level language called <strong>Macrocode</strong> on top of Microcode. Because of this abstraction layer, Macrocode changes less frequently then that of Microcode, and is more portable. Also, do to its abstraction layer, is more easier to work with.</p>
<p>It is still, however, very low level. It is used as the internal logic instruction set to convert higher level machine language into Microcode--which is translated by the Instruction Decoder.</p>
<h3 id="level-3-ring-0---kernel-level">Level 3: Ring 0 - Kernel Level</h3>
<p>This is where we are at. The Stage 2 Bootloaders only focus was to set everything up so that our Kernel has an environment to run in.</p>
<p>Our Kernel provides the abstraction between Device Drivers and Applications software, and the firmware that the hardware uses.</p>
<h3 id="level-4-rings-1-and-2---device-drivers">Level 4: Rings 1 and 2 - Device Drivers</h3>
<p>Device Drivers go through the Kernel to access the hardware. Device Drivers need a lot of freedom and control because they require direct control over specific microcontrollers. Having <strong>to much</strong> control, however, can crash the system. For example, what would happen if a driver modified the GDT, or set up its own? Doing so will immediately crash the kernel. Because of this, we will want to insure these drivers cannot use <strong>LGDT</strong> to load its own GDT. <strong>This is why we want these drivers to operate at either Ring 1 or Ring 2--Not ring 0</strong>.</p>
<p>For an example, a <strong>Keyboard Device Driver</strong> will need to provide the interface between <strong>Applications software</strong> and the <strong>Keyboard Microcontroller</strong>. The driver may be loaded by the Kernel as a library providing the routines to indirectly access the controller.</p>
<p>As long as there is a standard interface used, we can provide a very portable Kernel as long as we hide all hardware dependencies.</p>
<h3 id="level-5-ring-3---applications-level">Level 5: Ring 3 - Applications Level</h3>
<p>This is where the software are at. They use the interfaces provided by the System API and Device Driver interfaces. Normally they do not access the Kernel directly.</p>
<h3 id="conclusion-abstraction-layers-of-software">Conclusion (Abstraction Layers of Software)</h3>
<p>This Series will be developing the drivers during the development of the Kernel. This will allow us to keep things object oriented, and provide abstraction layer for the Kernel.</p>
<p>With that in mind, notice where we are at--<strong>Level 0</strong>. All other programs rely on the Kernel. Why? Lets look at the Kernel...</p>
<h2 id="the-kernel">The Kernel</h2>
<p>Because the Kernel is the Core component, it needs to provide the management for everything that relies on it. <strong>The primary purpose of the Kernel is to manage system resources, and provide an interface so other programs can access these resources.</strong> In a lot of cases, the Kernel itself is unable to use the interface it provides to other resources. <strong>It has been stated that the Kernel is the most complex and difficult tasks in programming.</strong></p>
<p>This implies that designing and implementing a good Kernel is very difficult.</p>
<p>In <strong>Tutorial 2</strong> we took a brief look at different past operating systems. We have bolded a lot of new terms inside that tutorial--and have compiled a list of those terms at the end of the tutorial. This is where that list starts getting implemented.</p>
<p>Lets first look at that list again, and look at how it related to the Kernel. Everything <strong>Bolded</strong> is handled by the Kernel:</p>
<ul>
<li><strong>Memory Management</strong></li>
<li><strong>Program Management</strong></li>
<li><strong>Multitasking</strong></li>
<li><strong>Memory Protection</strong></li>
<li>Fixed Base Address - This was covered in Tutorial 2</li>
<li>Multiuser - This is usually implemented by a shell</li>
<li><strong>Kernel</strong> - Of course</li>
<li><strong>File System</strong></li>
<li>Command Shell</li>
<li>Graphical User Interface (GUI)</li>
<li>Graphical Shell</li>
<li>Linear Block Addressing (LBA) - This was covered in Tutorial 2</li>
<li>Bootloader -Completed</li>
</ul>
<p>Some of the above can be implemented as separate drivers, used by the Kernel. For example, Windows uses <strong>ntfs.sys</strong> as an NTFS Filesystem Driver.</p>
<p>This list should look familiar from <strong>Tutorial 2</strong>. We have also covered some of these terms. Lets look at the <strong>bolded</strong> terms, and see how they relate to the Kernel. We will also look at some new concepts.</p>
<h3 id="memory-management">Memory Management</h3>
<p>This is quite possibly the most important part of any Kernel. And rightfully so--all programs and data require it. As you know, in the Kernel, because we are still in <strong>Supervisor Mode</strong> (Ring 0), <strong>We have direct access to every byte in memory</strong>. This is very powerful, but also produces problems, especially in a multitasking environment, where multiple programs and data require memory.</p>
<p>One of the primary problems we have to solve is: What do we do when we run out of memory?</p>
<p>Another problem is <strong>fragmentation</strong>. <strong>It is not always possible to load a file or program into a sequential area of memory</strong>. For an example, lets say we have 2 programs loaded. One at 0x0, the other at 0x900. Both of these programs requested to load files, so we load the data files:</p>
<p><img src="../../resources/images/MemFrag.gif" alt="Fragmentation of memory while using it in the OS"></p>
<p>Notice what is happening here. There is a lot of unused memory between all of these programs and files. Okay...What happens if we add a bigger file that is unable to fit in the above? This is when big problems arise with the current scheme. We cannot directly manipulate memory in any specific way, as it will corrupt the currently executing programs and loaded files.</p>
<p>Then there is the problems of where each program is loaded at. Each program will be required to be <strong>Position Independent</strong> or provide <strong>relocation Tables</strong>. Without this, we will not know what base address the program is supposed to be loaded at.</p>
<p>Lets look at these deeper. Remember the <strong>ORG</strong> directive? This directive sets the location where your program is expected to load from. By loading the program at a different location, the program will reference incorrect addresses, and will crash. We can easily test this theory. Right now, Stage2 expects to be loaded at 0x500. However, if we load it at 0x400 within Stage1 (While keeping the <strong>ORG 0x500</strong> within Stage2), a triple fault will occur.</p>
<p>This adds on two new problems. How do we know where to load a program at? Considering all we have is a binary image, we <strong>cannot</strong> know. However, if we make it standard that all programs begin at the same address--lets say, 0x0, then we can know. This would work--but is impossible to implement if we plan to support multitasking. <strong>However, if we give each program there own memory space, that virtually begins at 0x0, this will work.</strong> After all, from each programs' perspective, they are all loaded at the same base address--even if they are different in the real (physical) memory.</p>
<p>What we need is some way to abstract the physical memory. Lets look closer.</p>
<h4 id="virtual-address-space-vas">Virtual Address Space (VAS)</h4>
<p>A <strong>Virtual Address Space</strong> is a <strong>Program's Address Space</strong>. One needs to take note that this does <strong>not</strong> have to do with <strong>System Memory</strong>. The idea is <strong>so that each program has their own independent address space.</strong> <strong>This insures one program cannot access another program, because they are using a different address space.</strong></p>
<p>Because <strong>VAS</strong> is <strong>Virtual</strong> and not directly used with the physical memory, it allows the use of other sources, such as disk drives, as if it was memory. That is, <strong>It allows us to use more memory then what is physically installed in the system.</strong></p>
<p>This fixes the &quot;Not enough memory&quot; problem.</p>
<p>Also, as each program uses its own <strong>VAS</strong>, we can have each program always begin at base 0x0000:0000. This solves the relocation problems discussed earlier, as well as memory fragmentation--as we no longer need to worry about allocating continuous physical blocks of memory for each program.</p>
<p><strong>Virtual Addresses are mapped by the Kernel trough the MMU. More on this a little later.</strong></p>
<h4 id="virtual-memory-abstract">Virtual Memory: Abstract</h4>
<p><strong>Virtual Memory</strong> is a special <strong>Memory Addressing Scheme</strong> implemented by both the hardware and software. It allows non contiguous memory to act as if it was contiguous memory.</p>
<p>Virtual Memory is based off the <strong>Virtual Address Space</strong> concepts. It provides every program its own Virtual Address Space, allowing memory protection, and decreasing memory fragmentation.</p>
<p>Virtual Memory also provides a way to indirectly use more memory then we actually have within the system. One common way of approaching this is by using <strong>Page files</strong>, stored on a <strong>hard drive</strong>.</p>
<p>Virtual Memory needs to be mapped through a hardware device controller in order to work, as it is handled at the hardware level. This is normally done through the <strong>MMU</strong>, which we will look at later.</p>
<p>For an example of seeing virtual memory in use, lets look at it in action:</p>
<p><img src="../../resources/images/virtual-memory%5B1%5D.png" alt="Mixture of Physical and Disk addresses into the VAS"></p>
<p>Notice what is going on here. Each memory block within the <strong>Virtual Addresses</strong> are linear. Each Memory Block is <strong>mapped</strong> to either it's location within the real physical RAM, or another device, such as a hard disk. The blocks are swapped between these devices as an as needed bases. This might seem slow, but it is very fast thanks to the MMU.</p>
<p><strong>Remember: Each program will have its own Virtual Address Space--shown above.</strong> Because each address space is linear, and begins from 0x0000:00000, this immediately fixes a lot of the problems relating to memory fragmentation and program relocation issues.</p>
<p>Also, because <strong>Virtual Memory</strong> uses different devices in using memory blocks, it can easily manage more then the amount of memory within the system. i.e., If there is no more system memory, we can allocate blocks on the hard drive instead. If we run out of memory, we can either increase this page file on an as needed bases, or display a warning/error message,</p>
<p>Each memory &quot;Block&quot; is known as a <strong>Page</strong>, which is usually <strong>4096 bytes</strong> in size.</p>
<p>Once again, we will cover everything in much detail later.</p>
<h4 id="memory-management-unit-mmu-abstract">Memory Management Unit (MMU): Abstract</h4>
<p>My, oh my, where have we heard this term before? o.0 😀</p>
<p>The MMU, Also known as <strong>Paged Memory Management Unit (PMMU)</strong> is a component inside the microprocessor responsible for the management of the memory requested by the CPU. It has a number of responsibilities, including <strong>Translating Virtual Addresses to Physical Addresses, Memory Protection, Cache Control, and more.</strong></p>
<h4 id="segmentation-abstract">Segmentation: Abstract</h4>
<p>Segmentation is a method of <strong>Memory Protection</strong>. In Segmentation, we only allocate a certain address space from the currently running program. This is done through the <strong>hardware registers</strong>.</p>
<p>Segmentation is one of the most widely used memory protection scheme. On the x86, it is usually handled by the <strong>segment registers</strong>: CS, SS, DS, and ES.</p>
<p>We have seen the use of this through Real Mode.</p>
<h4 id="paging-abstract">Paging: Abstract</h4>
<p>THIS will be important to us. Paging is the process of managing program access to the virtual memory pages that are not in RAM. We will cover this a lot more later.</p>
<h3 id="program-management">Program Management</h3>
<p>THIS is where the ring levels start getting important.</p>
<p>As you know, Our Kernel is at Ring 0, while the applications are at Ring 3. This is good, as it prevents the applications direct access to certain system resources. This is also bad, as a lot of these resources are needed by the applications.</p>
<p>You might be curious on how the processor knows what ring level it is in, and how we can switch ring levels. The processor simply uses an internal flag to store the current ring level. Okay, but how does the processor know what ring to execute the code in?</p>
<p>This is where the <strong>GDT and LDT</strong> become important.</p>
<p>As you know, in Real Mode, there is no protection levels. Because of this, everything is &quot;Ring 0&quot;. Remember that <strong>we have to set up a GDT prior to going into protected mode?</strong> Also, remember that we needed to execute a <strong>far jump</strong> to enter the 32 bit mode. Lets go over this in more detail here, as they will play very important roles here.</p>
<h4 id="supervisor-mode">Supervisor Mode</h4>
<p>Ring 0 is known as <strong>supervisor mode</strong>. It has access to every instruction, register, table, and other, more privileged resources that no other applications with higher ring levels can access.</p>
<p>Ring 0 is also known as <strong>Kernel level</strong>, and is <strong>expected</strong> never to fail. If a ring 0 program crashes, it will take the system down with it. Remember that: <strong><em>&quot;With great power comes great responsibility&quot;</em></strong>. This is the primary reason for protected mode. 😉</p>
<p>Supervisor Mode utilizes a hardware flag that can be changed by system level software. System level software (Ring 0) will have this flag set, while application level software (Ring 3) will not.</p>
<p>There are a lot of things that only Ring 0 code can do, that Ring 3 code cannot. Remember the flags register from <strong>Tutorial 7</strong>? The <strong>IOPL Flag</strong> of the RFLAGS register determines what level is required to execute certain instructions, such as <strong>IN and OUT</strong> instructions. Because the IOPL is usually 0, this means that <strong>Only Ring 0 programs have direct access to hardware via software ports.</strong> Because of this, we will need to switch back to Ring 0 often.</p>
<h4 id="kernel-space">Kernel Space</h4>
<p><strong>Kernel Space</strong> refers to a special region of memory that is reserved for the Kernel, and Ring 0 device drivers. In most cases, <strong>Kernel Space should never be swapped out to disk, like virtual memory</strong>.</p>
<p>If an operating software runs in <strong>User Space</strong>, it is often known as <strong>&quot;Userland&quot;</strong>.</p>
<h4 id="user-space">User Space</h4>
<p>This is normally the <strong>Ring 3 application programs</strong>. Each application usually executes in its own <strong>Virtual Address Space (VAS)</strong> and can be swapped from different disk devices. <strong>Because each application is within their own virtual memory, they are unable to access another programs memory directly.</strong> Because of this, they will be required to go through a Ring 0 program to do this. This is necessary for <strong>Debuggers</strong>.</p>
<p>Applications are normally the least privileged. Because of this, they usually need to request support from a ring 0 Kernel level software to access system resources.</p>
<h4 id="switching-protection-levels">Switching Protection Levels</h4>
<p>What we need is a way so that these applications can query the system for these resources. However, to do this, we need to be in Ring 0, Not Ring 3. Because of this, we need a way to switch the processor state from Ring 3 to Ring 0, and allow applications to query our system.</p>
<p>Remember back in <strong>Tutorial 5</strong> we covered the rings of assembly language. Remember that the processor will change the current ring level under these conditions:</p>
<ul>
<li>A directed instruction, such as a <strong>far jump, far call, fat ret</strong> etc.</li>
<li>A <strong>trap</strong> instruction, such as <strong>INT, SYSCALL, SYSEXIT, SYSENTER, SYSRETURN</strong> etc.</li>
<li><strong>Exceptions</strong></li>
</ul>
<p>So...In order for an application to execute a system routine (while switching to Ring 0), the application must either <strong>far jump</strong>, execute an <strong>Interrupt</strong>, or use a special instruction, such as <strong>SYSENTER</strong>.</p>
<p>This is great--but how does the processor know what ring level to switch into? This is where the GDT comes into play.</p>
<p>Remember that, in each descriptor of the GDT, we had to set up the <strong>Ring Level</strong> for each descriptor? In our current GDT, We have 2 descriptors: Each for Kernel Mode Ring 0. <strong>This is our Kernel Space</strong>.</p>
<p>All we need to do is to add 2 mode descriptors to our current GDT, <strong>but set for Ring 3 access</strong>. <strong>This is our User Space</strong>.</p>
<p>Lets take a closer look.</p>
<p><strong>Remember from tutorial 8 that the important byte here is the access byte!</strong>. Because of this, here is the byte pattern again:</p>
<ul>
<li>Bit 0 (Bit 40 in GDT): Access bit (Used with Virtual Memory). Because we don't use virtual memory (Yet, anyway), we will ignore it. Hence, it is 0</li>
<li>Bit 1 (Bit 41 in GDT): is the readable/writable bit. Its set (for code selector), so we can read and execute data in the segment (From 0x0 through 0xFFFF) as code</li>
<li>Bit 2 (Bit 42 in GDT): is the &quot;expansion direction&quot; bit. We will look more at this later. For now, ignore it.</li>
<li>Bit 3 (Bit 43 in GDT): tells the processor this is a code or data descriptor. (It is set, so we have a code descriptor)</li>
<li>Bit 4 (Bit 44 in GDT): Represents this as a &quot;system&quot; or &quot;code/data&quot; descriptor. This is a code selector, so the bit is set to 1.</li>
<li>Bits 5-6 (Bits 45-46 in GDT): is the privilege level (i.e., Ring 0 or Ring 3). We are in ring 0, so both bits are 0.</li>
<li>Bit 7 (Bit 47 in GDT): Used to indicate the segment is in memory (Used with virtual memory). Set to zero for now, since we are not using virtual memory yet</li>
</ul>
<pre><code class="lang-armasm">;*******************************************
; Global Descriptor Table (GDT)
;*******************************************

gdt_data:

; Null descriptor (Offset: 0x0)--Remember each descriptor is 8 bytes!
    dd 0                 ; null descriptor
    dd 0

; Kernel Space code (Offset: 0x8 bytes)
    dw 0FFFFh            ; limit low
    dw 0                 ; base low
    db 0                 ; base middle
    db 10011010b         ; access - Notice that bits 5 and 6 (privilege level) are 0 for Ring 0
    db 11001111b         ; granularity
    db 0                 ; base high

; Kernel Space data (Offset: 16 (0x10) bytes
    dw 0FFFFh            ; limit low (Same as code)10:56 AM 7/8/2007
    dw 0                 ; base low
    db 0                 ; base middle
    db 10010010b         ; access - Notice that bits 5 and 6 (privilege level) are 0 for Ring 0
    db 11001111b         ; granularity
    db 0                 ; base high

; User Space code (Offset: 24 (0x18) bytes)
    dw 0FFFFh            ; limit low
    dw 0                 ; base low
    db 0                 ; base middle
    db 11111010b         ; access - Notice that bits 5 and 6 (privilege level) are 11b for Ring 3
    db 11001111b         ; granularity
    db 0                 ; base high

; User Space data (Offset: 32 (0x20) bytes
    dw 0FFFFh            ; limit low (Same as code)10:56 AM 7/8/2007
    dw 0                 ; base low
    db 0                 ; base middle
    db 11110010b         ; access - Notice that bits 5 and 6 (privilege level) are 11b for Ring 3
    db 11001111b         ; granularity
    db 0                 ; base high
</code></pre>
<p>Notice what is happening here. All code and data have the same range values--the only difference is that of the <strong>Ring</strong> levels.</p>
<p>As you know, <strong>protected mode</strong> uses CS to store the <strong>Current Privilege Level (CPL)</strong>. When entering protected mode for the first time, <strong>We needed to switch to Ring 0</strong>. Because the value of CS was invalid (From real mode), we need to choose the correct descriptor from the GDT into CS. <strong>Please see Tutorial 8 for more information</strong>.</p>
<p>This required a far jump, as we needed to upload a new value into CS. By <strong>far jumping</strong> to a Ring 3 descriptor, we can effectively enter a Ring 3 state.</p>
<p>As, as you know, we can use a <strong>INT, SYSCALL/SYSEXIT/SYSENTER/SYSRET, far call, or an exception</strong> to have the processor switch back to Ring 0.</p>
<p>Lets take a look closer at these methods...</p>
<h4 id="system-api-abstract">System API: Abstract</h4>
<p>The program relies on the System API to access system resources. Most applications reference the System API directly, or through their language API--Such as the <strong>C runtime library</strong>.</p>
<p>The System API provides the <strong>Interface</strong> between applications and system resources through <strong>System Calls</strong>.</p>
<h4 id="interrupts">Interrupts</h4>
<p>A <strong>Software Interrupt</strong> is a special type of interrupt implemented in software. Interrupts are used quite often, and rely on the use of a special table--the <strong>Interrupt Descriptor Table (IDT)</strong>. We will look at Interrupts a lot more closer later, as it is the first thing we will implement in our Kernel.</p>
<p>Linux uses INT 0x80 for all system calls.</p>
<p><strong>Interrupts are the most portable way to implement system calls.</strong> Because of this, we will be using interrupts as the first way of invoking a system routine.</p>
<h4 id="call-gates">Call Gates</h4>
<p>Call Gates provide a way for Ring 3 applications to execute more privileged (Ring 0,1,2) code. The <strong>Call gate</strong> interfaces between the Ring 0 routines and the Ring 3 applications, and is normally set up by the Kernel.</p>
<p>Call Gates provide a single gate (Entry point) to FAR CALL. This entry point is defined within the GDT or LDT.</p>
<p>It is much easier to understand a call gate with an example.</p>
<pre><code class="lang-armasm">;*******************************************
; Global Descriptor Table (GDT)
;*******************************************

gdt_data:

; Null descriptor (Offset: 0x0)--Remember each descriptor is 8 bytes!
    dd 0                 ; null descriptor
    dd 0

; Kernel Space code (Offset: 0x8 bytes)
    dw 0FFFFh            ; limit low
    dw 0                 ; base low
    db 0                 ; base middle
    db 10011010b         ; access - Notice that bits 5 and 6 (privilege level) are 0 for Ring 0
    db 11001111b         ; granularity
    db 0                 ; base high

; Kernel Space data (Offset: 16 (0x10) bytes
    dw 0FFFFh            ; limit low (Same as code)10:56 AM 7/8/2007
    dw 0                 ; base low
    db 0                 ; base middle
    db 10010010b         ; access - Notice that bits 5 and 6 (privilege level) are 0 for Ring 0
    db 11001111b         ; granularity
    db 0                 ; base high

; Call gate (Offset: 24 (0x18) bytes

 CallGate1:
    dw (Gate1 &amp; 0xFFFF)  ; limit low address of gate routine
    dw 0x8               ; code segment selector
    db 0                 ; base middle
    db 11101100b         ; access - Notice that bits 5 and 6 (privilege level) are 11 for Ring 3
    db 0                 ; granularity
    db (Gate1 &gt;&gt; 16)     ; base high of gate routine

; End of the GDT. Define the routine wherever

; The call gate routine

Gate1:
    ; do something special here at Ring 3

    retf            ; far return back to calling routine
</code></pre>
<p>The above is an example of a call gate.</p>
<p>To execute the call gate, we offset from the <strong>descriptor code</strong> within the GDT. Notice how similar this is from our <strong>jmp 0x8:Stage2</strong> instruction:</p>
<pre><code class="lang-armasm">; execute the call gate
    call far    0x18:0            ; far call--calls our Gate1 routine
</code></pre>
<p>Call Gates are not used too often in modern operating systems. One of the reasons is that most architectures do not support Call Gates. They are also quite slow as they require a <strong>FAR CALL</strong> and <strong>FAR RET</strong> instructions.</p>
<p>On systems where the GDT is not in protected memory, it is also possible for other programs to create their own Call Gates to raise its protection level (and get Ring 0 access.) They have also been known to have security issues. One notable worm, for example, is <strong>Gurong</strong>, which installs its own call gate in the Windows Operating System.</p>
<h4 id="sysenter--sysexit-instructions">SYSENTER / SYSEXIT Instructions</h4>
<p>These instructions were introduced from the Pentium II and later CPUs. Some recent AMD processors also support these instructions.</p>
<p><strong>SYSENTER</strong> can be executed by any application. <strong>SYSRET</strong> can only be executed by Ring 0 programs.</p>
<p>These instructions are used as a fast way to transfer control from a User Mode (Ring 3) to a Privilege Mode (Ring 0), and back quickly. This allows a fast and safe way to execute system routines from user mode.</p>
<p><strong>These instructions directly rely on the Model Specific Registers (MSR's). Please see Tutorial 7 for an explanation of MSRs, and the RDMSR and WRMSR instructions.</strong></p>
<h5 id="sysenter">SYSENTER</h5>
<p>The <strong>SYSENTER</strong> instruction automatically sets the following registers to their locations defined within the MSR:</p>
<ul>
<li>CS = IA32_SYSENTER_CS MSR + the value 8</li>
<li>ESP = IA32_SYSENTER_ESP MSR</li>
<li>EIP = IA32_SYSENTER_IP MSR</li>
<li>SS = IA32_SYSENTER_SS MSR</li>
</ul>
<p>This instruction is only used to transfer control from a Ring 3 code to Ring 0. At startup, we will need to set these MSR's to point to a <strong>Starting location</strong> which will be our <strong>Syscall Entry Point</strong> for all system calls.</p>
<p>Lets take a look at SYSEXIT.</p>
<h5 id="sysexit">SYSEXIT</h5>
<p>The <strong>SYSEXIT</strong> instruction automatically sets the following registers to their locations defined within the MSR:</p>
<ul>
<li>CS = IA32_SYSENTER_CS MSR + the value 16</li>
<li>ESP = ECX Register</li>
<li>EIP = EDX Register</li>
<li>SS = IA32_SYSENTER_CS MSR MSR + 24</li>
</ul>
<h5 id="using-sysentersysexit">Using SYSENTER/SYSEXIT</h5>
<p>Okay, using these instructions might seem complicated, but they are not too hard 😉</p>
<p>Because SYSENTER and SYSEXIT require that the MSR's are set up <strong>prior</strong> to calling them, we first need to initialize those MSRs.</p>
<p><strong>Remember that IA32_SYSENTER_CS is index 0x174, IA32_SYSENTER_ESP is 0x175, and IA32_SYSENTER_IP is 0x176 within the MSR. Remember from tutorial 7?</strong></p>
<p>Knowing this, lets set them up for SYSENTER:</p>
<pre><code class="lang-armasm">    %define IA32_SYSENTER_CS 0x174
    %define IA32_SYSENTER_ESP 0x175
    %define IA32_SYSENTER_EIP 0x176

    mov    eax, 0x8                ; kernel code descriptor
    mov    edx, 0
    mov    ecx, IA32_SYSENTER_CS
    wrmsr

    mov    eax, esp
    mov    edx, 0
    mov    ecx, IA32_SYSENTER_ESP
    wrmsr

    mov    eax, Sysenter_Entry
    mov    edx, 0
    mov    ecx, IA32_SYSENTER_EIP
    wrmsr

    ; Now, we can use sysenter to execute Sysenter_Entry at ring 0 from either a Ring 0 program or Ring 3:
    sysenter

Sysenter_Entry:

    ; sysenter jumps here, is is executing this code at privilege level 0\. Similar to Call Gates, normally we will
    ; provide a single entry point for all system calls.
</code></pre>
<p>If the code that executes <strong>sysenter</strong> is at Ring 3, and <strong>Sysenter_Entry</strong> is at protection level 0, the processor will switch modes within the <strong>SYSENTER</strong> instruction.</p>
<p>in the above code, both are at Protection Level 0, so the processor will just call the routine without changing modes.</p>
<p>As you can see, there is a bit of work that must be done prior to calling SYSENTER.\ and SYSEXIT.</p>
<p><strong>SYSENTER and SYSEEXIT are not portable.</strong> Because of this, it is wise to implement another, more portable, method alongside SYSENTER/SYSEXIT.</p>
<h4 id="syscall--sysret-instructions">SYSCALL / SYSRET Instructions</h4>
<p>[I plan on adding a section for SYSCALL and SYSRET here soon]</p>
<h4 id="error-handling">Error Handling</h4>
<p>What do we do if a program causes a problem? How will we know what that problem is and how to handle it?</p>
<p>Normally this is done by means of <strong>Exception Handling</strong>. Whenever the processor enters an invalid state caused by an invalid instruction, divide by 0, etc; the processor triggers an <strong>Interrupt Service Routine (ISR)</strong>. If you have mapped our own ISR's, it will call our routines.</p>
<p>The <strong>ISR</strong> called depends on what the problem was. This is great, as we know what the problem is, and can try finding the program that originally caused the problem.</p>
<p>One way of doing this is simply getting the last program that you have given processor time to. That is guaranteed to be the one that has generated the ISR.</p>
<p>Once you have the programs information, then one can either output an error or attempt to shutdown the program.</p>
<p><strong>IRQs are mapped by the internal Programmable Interrupt Controller (PIC) inside the processor. They are mapped to interrupt entries within the Interrupt Descriptor Table (IDT). This is the first thing we will work on inside the Kernel, so we will cover everything later.</strong></p>
<h2 id="conclusion">Conclusion</h2>
<p>We looked at a lot of different concepts in this tutorial, ranging from Kernel theory, memory management concepts, Virtual Memory Addressing (VMA), and program management, including separating Ring 0 from Ring 3, and providing the interface between applications and system software. Whew! That's a lot, don't you think?</p>
<p>a lot of the concepts in this tutorial may be new to you--don't worry. This is more of a &quot;Get your feet wet&quot; tutorial, where we cover all of the basic concepts related to Kernels.</p>
<p>This tutorial has barely scratched the surface of what a Kernel must do. That is a start, though. 😉</p>
<p>In the next tutorial, we are going to look at Kernels from another perspective. We will cover some new concepts yet again, and talk about Kernel designs and implementations. Afterwards, we will start building our compilers and toolchains to work with C and C++. Sound fun?</p>
<p>I am currently using MSVC++ 2005 for my Kernel.</p>
<p>We will also finish off other concepts that we have not looked at here, including <strong>multitasking, TSS, Filesystems</strong>, and more. <em>Its going to be fun 😉</em></p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/enygmator/BrokenThorn-OS-Dev-Series/blob/master/docfx_base/articles/61_unorganised_tutorial/T12.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            <span><strong>Project (v2.0)</strong> created by <a href="https://github.com/enygmator/">@enygmator</a><br>Tutorial authored by <a href="http://www.brokenthorn.com/">BrokenThorn Entertainment Co.</a><br>Generated by <strong>DocFX v2.56.1</strong></span>
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
