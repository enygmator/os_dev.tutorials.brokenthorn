<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Graphics 1 | BrokenThorn OS Dev Tutorials </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Graphics 1 | BrokenThorn OS Dev Tutorials ">
    <meta name="generator" content="docfx 2.56.1.0">
    
    <link rel="shortcut icon" href="../../resources/icons/favicon.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="../toc.html">
    
    <meta property="docfx:rel" content="../../">
    <meta property="docfx:newtab" content="true">
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../resources/images/favicon.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list"></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="graphics-1">Graphics 1</h1>

<p>Welcome!</p>
<p>Wait, what? Graphics already? Thats right, we will start developing an ultra-cool GUI for the OS! 😀 Okay, not really, but its a start in that direction.</p>
<p>This chapter is the first of a miniseries of chapters covering graphics programming. I plan to cover Vesa VBE, Video BIOS, and direct hardware programming for the VGA and, possibly, some SVGA concepts. I also plan on covering graphics concepts and rendering, including 2d vector rendering and images. Who knows; mabye a little 3d a little later.</p>
<p>Excited? A lot of cool material coming up in this mini series spinoff of the OS Development Series! However, before we can dive into the wonderful world of computer graphics, we have to set up a ground rule. There are a lot of ways that we can work with computer graphics, and a lot of directions that we can take. Computer graphics are a complicated topic: It cannot be covered in one chapter. Well, it can. It would just be one .. very, very long chapter.</p>
<p>Because of this, I decided to do this in stages. The first chapter covers working with graphics in real or v86 modes. We use the system BIOS interrupts and cover basic graphics concepts. The second chapter we will dive into Video BIOS Extensions (VBE) and Super VGA. The third chapter, will be the first chapter of a smaller miniseries covering direct hardware programming of the graphics pipeline: VGA and mabye some Super VGA topics.</p>
<p>So for this chapter, lets get started with working with real mode graphics using the real mode Video BIOS...</p>
<h2 id="basic-concepts">Basic Concepts</h2>
<h3 id="abstract">Abstract</h3>
<p><strong>Computer Graphics (CG)</strong> does not need an introduction. It has revolutionized the computer, animation, and video game industries. The field of computer graphics encompasses the development, creation, and continuation of the ability of producing graphical effects on computer displays. From 1D graphics, 2D, 3D, and even 4D graphics simulation software.</p>
<h3 id="history">History</h3>
<p>The computer graphics industry started to emerge from early projects like the <strong>Whirlwind</strong> in the 1960's. The Whirlwind was the first computer that used video display output and helped introduce the <strong>Cathode Ray Tube (CRT)</strong> technology. Whirlwind eventually led to the development of the SAGE (Air Force Semi Automatic Ground Environment) computer system. The ealiest known version of the CRT was created by Ferdinand Braun in 1897 known as the <em>Braun tube</em>.</p>
<p>The <strong>Special Interest Group on GRAPHics and Interactive Techniques (SIGGRAPH)</strong>, is governed by the <strong>Association for Computing Machinery (ACM) SIGGRAPH</strong> group. Originally started in 1969 by Andy van Dam, the group hosts the SIGGRAPH conferences around the world. These conferences are attended by thousands of professionals from companies from the engineering, graphics, motion picture, and video game industries.</p>
<p>As graphics hardware advanced the ability of creating more powerful graphics designs emerged. As other display technologies emerges, such as <strong>Liquid Crystal Display (LCD)</strong>, The use of the CRT technology started to decline.</p>
<p><strong>Video Display Terminals (VDT)</strong>, also known as a <strong>Video Display unit (VDU)</strong> are early display terminals.</p>
<h3 id="cathode-ray-tube-crt">Cathode ray tube (CRT)</h3>
<p><img src="../../resources/images/crt.png" alt="Cathode ray tube"></p>
<h4 id="abstract-crt">Abstract (CRT)</h4>
<p>A CRT is a vacuum tube which consists of electron guns and a phosphor target. The entire front area of the tube is scanned repetitibely in a pattern called a <strong>raster</strong>. The image is produced by changing the intensity of the three electron beams: one for red, green, and blue color components at a given point on display. These electron beams first travel through a <strong>Shadow Mask</strong> layer before hitting the phosphor coated screen.</p>
<h4 id="problems">Problems</h4>
<p>CRT monitors can emit a small amount of X-Ray radiation. Also, do to the constant rescanning of the display, at low <strong>refresh rates</strong> (below 60Hz) flicker may be seen. CRTs may also contain some toxic phosphore. Because of this the United States Environmental Protection Agency (EPA) created a rule that CRTs must be bought to a proper recycling facility. Finally, do to the CRT containing a vaccum of glass, if the outer glass is damaged, the CRT may implode. This may cause the glass to shatter outward at dangerous speeds. Modern CRTs have certain measures in place to prevent the shattering of the CRT.</p>
<p><strong>It is possible to control the frequency of the CRT using software.</strong> At higher frequency rates, it is possible to make the CRT operate faster then its intended use increasing the possibility of imploding the CRT. Because of this, it is very important to be careful when working with the <strong>CRT Controller (CRTC)</strong>. Modern CRTs have protections in place to prevent this, however.</p>
<h2 id="vga">VGA</h2>
<h3 id="abstract-vga">Abstract (VGA)</h3>
<p><strong>The Video Graphics Array (VGA)</strong> is an anolog computer display standard marketed in 1987 by IBM. It is called an &quot;Array&quot; because it was originally developed as a single chip, replacing dozens of logic chips in a Industry Standard Architecture (ISA) board that the MDA, CGA, and EGA used. Because this was all on a single ISA board, it was very easy to connect it to the motherboard.</p>
<p>The VGA consists of the video buffer, video DAC, CRT Controller, Sequencer unit, Graphics Controller, and an Attribute Controller. We will cover all of these components in more detail in later chapters.</p>
<h4 id="video-buffer">Video Buffer</h4>
<p>The <strong>Video Buffer</strong> is a segment of memory mapped as Video Memory. We can change what region of memory is mapped to video memory. At startup, the BIOS maps it to 0xA0000., which means that video memory is mapped to 0xA0000. (Remember the Real Mode Address Map from Tutorial 7?) We will cover memory mapping a little later in this chapter in more detail.</p>
<h4 id="video-dac">Video DAC</h4>
<p>The <strong>Video Digital to Analog Converter (DAC)</strong> contains the color palette that is used to convert the video data into an analog video signal that is sent to the display. This signal indicates the red, green, and blue intensities in analog form. We will go into more detail later, so don't worry if you do not understand this yet.</p>
<h4 id="crt-controller">CRT Controller</h4>
<p>This controller generates horizontal and vertical synchronization signal timings, addressing for the video buffer, cursor and underline timings. We will go into more detail later when we cover the VGA hardware.</p>
<h4 id="sequencer">Sequencer</h4>
<p>The Sequencer generates basic memory timings for video memory and the character clock for controlling regenerative buffer fetches. It allows the system to access memory during active display intervals. Once more, we will not cover this in detail yet.</p>
<h4 id="graphics-controller">Graphics Controller</h4>
<p>This is the interface between video memory and the <strong>attribute controller</strong>, and between video memory and the CPU. During active display times, memory data is sent from the video buffer (Video Memory) and sent to the Attribute Controller. In Graphics Modes, this data is converted from parallel to a serial bit plane data before being sent. In text modes, Just the parallel data is sent.</p>
<p>Don't worry if you do not understand these yet. I do not plan on going into much detail here. We will cover everything in detail later when we talk about developing a video driver. For now, just remember that: The Graphics Controller refreshes the display from the parallel data from video memory. This is automatic based on the active display times. This simply means, that By writing to video memory (Default mapped to 0xA0000) we effectivly write to video display, depending on the current mode. This is important when printing characters.</p>
<p>Remember that it is possible to change the address range used by the Graphics Cotroller. When initializing, the BIOS does just this to map video memory to 0xA0000.</p>
<h3 id="video-modes">Video Modes</h3>
<p>A &quot;Video Mode&quot; is a specification of display. That is, it describes how Video Memory is refrenced, and how this data is displayed by the video adapter.</p>
<p>The VGA supports two types of modes: APA Graphics, and Text.</p>
<h4 id="apa-graphics">APA Graphics</h4>
<p>All Points Addressable (APA) is a display mode, that, on a video monitor, dot matrix, or any device that consists of a pixel array, where every cell can be refrenced individually. In the case of video display, where every cell represents a &quot;pixel&quot;, where every pixel can be manipulated directly. Because of this, almost all graphic modes use this method. By modifying this pixel buffer, we effectivly modify individual pixels on screen.</p>
<p><strong>Pixel</strong>: A &quot;Pixel&quot; is the smallest unit that can be represented on a display. On a display, it represents the smallest unit of color. That is, basically, a single dot. The size of each pixel depends heavily on the current resolution and video mode.</p>
<h4 id="text-modes">Text Modes</h4>
<p>A Text Mode is a display mode where the content on the screen is internally represented in terms of characters rather then pixels, as with APA.</p>
<p>A Video Controller implimenting text mode uses two buffers: A character map representing the pixels for each individual character to be displayed, and a buffer that represents what characters are in each cell. By changing the character map buffer, we effectivly change the characters themselves, allowing us to create a new character set. By changing the Screen Buffer, which represents what characters are in each cell, we effectivly change what characters are displayed on screen. Some text modes also allow attributes, which may provide a character color, or even blinking, underlined, inversed, brightened, etc.</p>
<h3 id="mda-cga-ega">MDA, CGA, EGA</h3>
<p>Remember that VGA is based off of MDA, CGA, and EGA. VGA also supports alot of the modes these adapters do. Understanding these modes will help in better understanding VGA.</p>
<h4 id="mda">MDA</h4>
<p>Back before I was born (Seriously 😀) in 1981, IBM developed a standard video display card for the PC. They were the Monochrome Display Adapter (MDA), and Monochrome Display and Printer Adapter (MDPA).</p>
<p>The MDA did not have any graphics mode of any kind. It only had a single text mode, (Mode 7) which could display 80 columns by 25 lines of high resolution text characters.</p>
<p>This display adapter was a common standard used in older PC's.</p>
<h4 id="cga">CGA</h4>
<p>In 1981, IBM also developed the Color Graphics Adapter (CGA), coinsidered the first color display standard for PC's.</p>
<p>The CGA only supported a Color Palette of 16 colors, because it was limited to 4 bytes per pixel.</p>
<p>CGA supported two text modes and two graphics modes, including:</p>
<ul>
<li>40x25 characters (16 color) text mode</li>
<li>18x25 characters (16 color) text mode</li>
<li>320x200 pixels (4 colors) graphics modes</li>
<li>640x200 pixels (Monochrome) graphics mode</li>
</ul>
<p>It is possible to treak the display adapter in creating and discovering new, &quot;undocumented&quot; video modes. More on this later.</p>
<h4 id="ega">EGA</h4>
<p>Introduced in 1984 by IBM, The Enhanced Graphics Adapter (EGA) produced a display of 16 colors at a resolution up to 640x350 pixels.</p>
<p>Remember that the VGA adapters are backward compatible, simular to the 80x86 microprocessor family. Because of this, and to insure backward compatibility, the BIOS starts up in Mode 7 (Originally from the MDA), which supports 80 columns, by 25 lines. This is important to us, because this is the mode we are in!</p>
<h3 id="video-memory">Video Memory</h3>
<h4 id="memory-mapped-io-mmio">Memory Mapped I/O (MMIO)</h4>
<p>If you know what Memory Mapped I/O is, you can skip this part.</p>
<p><strong>The processor can work with reading from RAM and ROM devices.</strong> In applications programming, this is something you never see. This is made possible with MMIO devices. <strong>Memory Mapped I/O allows a hardware device to map its own RAM or ROM into your processors physical address space.</strong> This allows the processor to be able to access hardware RAM or ROM in different ways by just using a pointer to that location in the address space. This is made possible because MMIO devices uses the same physical address and data bus that the processor and system memory uses.</p>
<p>It is important to remember, however, that Memory Mapped I/O is a mapping to the physical address space of the processor, not actual computer memory. In some architectures, it is possible to <em>bank switch</em>, or provide a method to switch between either using the MMIO device mapping or the system memory &quot;hidden&quot; behind it, while on others it is not. What this means for us is that we cannot access the actual system memory addresses that are &quot;hidden&quot; by the MMIO device. For example, CMOS RAM memory is mapped into the physical address space at address 0x400. This is different then main system memory; accessing 0x400 with a pointer will access the CMOS RAM memory always do to MMIO. It is not possible to access this location in system memory in the i86 architecture.</p>
<p>MMIO devices allows us to have more control over the hardware - it allows high resolution video displays with limited system memory, it allows us to obtain information from a device that is kept current by a battery (CMOS RAM) that would have altherwise been lost if in system memory. Another example of an MMIO device is the system BIOS ROM itself. MMIO is what allows the processor to execute the BIOS from ROM as it is mapped to the systems physical address space. Cool, huh?</p>
<p>You might be wondering what this has to do with graphics. Video memory is RAM that is mapped into the physical address space. Video memory is managed by the video display device which uses MMIO to do this. <strong>How MMIO memory is managed and worked with is up to the device</strong>; it is not always nice and linear. Different graphics modes require different ways that you have to work with this memory, so understanding that it is an MMIO device is important.</p>
<p><strong>An interesting fact about MMIO address space regions is that, with paging they can be mapped to any virtual address and accessed from that address.</strong> This means you can map, for example, video memory, to any virtual address you want and access video memory using that virtual address. This, of course, has to do with the way pages are mapped to frames in the physical address space.</p>
<p><strong>Also remember that MMIO memory is not in system memory</strong>. Computer system memory does not need to be greater then the size of the MMIO address that you are trying to access. For example, if your system only has 2GB of system memory, you can still access the MMIO device if it has RAM mapped to the physical address space at 0xFC000000 without error.</p>
<p>See this text right here? Thats right, me; I am in your computer... residing in <strong>Video RAM (VRAM).</strong> VRAM is Video Memory, also known as the <strong>video framebuffer</strong>. It containes all of the pixels that you see before you, and more.</p>
<h4 id="standard-vga">Standard VGA</h4>
<p>Video memory is stored inside of the video device; usually a video card or onboard video adapter. Standard VGA cards have 256 KB of VRAM. It is not uncommon however to see SVGA+ cards to have much more video memory however. After all, they have to be able to store all of the pixels in the high resolution video modes somehow, right?</p>
<p>Remember the memory map from [chapter 7] (fix link)? We can see the Standard VGA memory resides in <strong>0x000A0000 - 0x000BFFFF</strong>. 0xBFFFF - 0xA0000 = 0xA0000, which is 655360 bytes, or 640 KB.</p>
<p>It is important to remember that video memory is mapped in the PCs address space at this location. What this means is by writing here, you are writing to video memory that is located in the video adapter. This is a form of <strong>Memory Mapped I/O</strong>.</p>
<p>When accessing video memory, you typically access it using a &quot;window&quot; into the real video RAM. This is typically:</p>
<ul>
<li>0xA0000 - EGA/VGA graphics modes (64 KB)</li>
<li>0xB0000 - Monochrome text mode (32 KB)</li>
<li>0xB8000 - Color text mode and CGA (32 KB)</li>
</ul>
<p>Because different modes uses different address mappings, it is possible to combine a monochome display adapter and color adapter on the same machine. This allows a computer with a dual monitor setup to be able to run without issues. Of course, this is just standard VGA.</p>
<h4 id="super-vga">Super VGA</h4>
<p>Super VGA and other display adapters typically do things differently. It is not uncommon to see a Super VGA or higher resolution display adapter to have VRAM mapped to a high address range. While they will usually support the Standard VGA memory mapped range, they can use other memory ranges as well to help with high resolution video modes or to provide additional functionality. For example, my NVideo GeForce 7600 GT has 4 memory ranges that it can use: 0xA0000 - 0x000BFFFFF (Look familier?), 0xFC000000 - 0xFCFFFFFF, 0xD0000000 - 0xDFFFFFFF, and 0xFD000000 - 0xFDFFFFFF. This can be different on your system.</p>
<h4 id="linear-frame-buffer-lfb">Linear Frame Buffer (LFB)</h4>
<p>If it is possible to map the entire video memory of the current display into the physical address space, it is possible to set it up to act like a linear frame buffer. A linear frame buffer is just a packed-pixel frame buffer that allows you to be able to read or write to it in linear fashion. For example, buffer[0] is the first element of the buffer, buffer[1] is the second - there is nothing special. Well, actually there is. Standard VGA does not support LFB modes. Remember Mode 0x13 above? That is the only Standard VGA video mode that creates the effect of a linear frame buffer.</p>
<p>This might be a little confusing. After all, how &quot;else&quot; can you read or write to video memory if its not in linear fashion? This has to do with Standard VGA being a <strong>planer</strong> device. We will talk about that after the next section,</p>
<h4 id="bank-switching">Bank Switching</h4>
<p>Super VGA and higher resolution video modes can also provide a way of using a &quot;window&quot; into the full video memory that is on the adapter. For example, notice above that, for graphics modes, we are limited to a 64KB region between <strong>0xA0000 - 0xB0000</strong>. If this was a &quot;window&quot;, and we can &quot;move&quot; this 64K window around, we can access a much larger video memory area. For example:</p>
<p><img src="../../resources/images/bankSwitch.png" alt="Bank Switching"></p>
<p>This is known as <strong>Bank Switching</strong>. A &quot;Bank&quot; is a window into the larger video memory. The size of the window is typically 64K do to standard VGA only having a graphics region of 64K.</p>
<h4 id="planer-memory">Planer Memory</h4>
<p>Okay, it gets a little tricky here. Standard VGA modes operate in planer memory mode. This is the VGAs native memory model.</p>
<p><img src="../../resources/images/planer.png" alt="Planer Memory"></p>
<p>The above is an example of Mode 12h's planer memory format. Mode 12h has 4 bits per pixel. To draw a pixel, you have to set or unset the bit in the plane. To better understand this, imagine you have a 64k block of video memory. Imagine it as a flat sheet of paper and put three more behind it. Each sheet of paper is a 64k &quot;plane&quot; that shares this same 64k area of memory. Each plane holds a little bit of information about the pixel that it is used for.</p>
<p>Dont worry to much about understanding planer memory and how it works, we wont be needing it in this chapter. It will be important when we cover VGA and Mode 12h in more detail however. Because we are using Mode 0x13, which hides the details of working with planer memory, we wont need it now.</p>
<h4 id="odd--even-memory-addressing">Odd / Even Memory Addressing</h4>
<p>Odd / Even Memory Addressing uses the Planer Memory model and <strong>is used in all text modes</strong>. All even addresses work with planes 0 or 2 and odd addresses work with planes 1 or 3. For example:</p>
<table>
<thead>
<tr>
<th>Memory Address</th>
<th>Plane</th>
<th>Offset in plane</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>Plane 0</td>
<td>Offset 0</td>
</tr>
<tr>
<td>1</td>
<td>Plane 1</td>
<td>Offset 0</td>
</tr>
<tr>
<td>2</td>
<td>Plane 0</td>
<td>Offset 2</td>
</tr>
<tr>
<td>3</td>
<td>Plane 1</td>
<td>Offset 2</td>
</tr>
</tbody>
</table>
<p>Remember what it is like writing to video memory in text modes?</p>
<pre><code class="lang-c">unsigned char* vmem = 0xb8000;
vmem[0] = 'a'; // plane 0 [character plane] offset 0
vmem[1] = 0x7; // plane 1 [attribute plane] offset 0
vmem[2] = 'b'; // plane 0 [character plane] offset 2
vmem[3] = 0x7; // plane 1 [attribute plane] offset 2
</code></pre>
<p><strong>In text modes, plane 0 is used to store character codes and plane 1 stores the attribute bytes. Plane 2 stores the font data.</strong> If you overwrite plane 2 when writing to video memory, you will overwrite the font installed at boot time by the BIOS. This means that, <strong>if you write over plane 2 in graphics mode, and go back to text mode, the BIOS text output routines will not work as expected as the font data is corrupt.</strong></p>
<p>If you would like to go back to text mode, you will either need to store your own font or backup the default font and write it back to plane 2 before using any text output routines again.</p>
<p>Because we are not using the planer memory model in this chapter, we wont be using the Odd/Even addressing model in this chapter.</p>
<h3 id="color-palette">Color Palette</h3>
<p>A <strong>Palette</strong> is like a look-up table. A <strong>Color Palette</strong> is a look-up table for colors. For example, we can store a list of the actual color information in a table. We can then use another table of <strong>indices</strong> into that table:</p>
<table>
<thead>
<tr>
<th>Index Table</th>
<th>Color Palette</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>red(0), green(0), blue(0)</td>
</tr>
<tr>
<td>1</td>
<td>red(0), green(0), blue(1)</td>
</tr>
<tr>
<td>2</td>
<td>red(0), green(1), blue(0)</td>
</tr>
</tbody>
</table>
<p>In the above example, we can reference whatever color we want by just using the index. That saves storage space greatly because after the look up table (The color palette) is created, any time that we want to refer to a color we just use the index.</p>
<p>For example, in a video mode that uses a color palette, video memory acts as the index buffer. So, to draw a pixel using the palette that we created above, just write the <strong>index</strong> of the color that you would like to use:</p>
<pre><code class="lang-c">unsigned char* p = 0xa0000;
p[0] = 0; // black pixel
p[1] = 1; // blue pixel
p[2] = 2; // green pixel
</code></pre>
<p>In the VGA, the Color Palette is handled by the hardware. We can control and change the colors in the palette however way we want. However, because working with the palette requires VGA hardware programming, we will not cover it too much here. Dont worry, we will cover it when we get into VGA hardware.</p>
<h4 id="palette-animation">Palette Animation</h4>
<p>Okay, lets take a step back for a moment. Look at the above example again. Notice that the video display will determin what the color is of a pixel by an index. What if, lets say, that the index 1 in the color palette (Like in the above example) changes to a different color? Looking at the above example, index 1 in the color palette is a bright blue color. So, if we are in a palette video mode, any time we write a &quot;1&quot; to someplace in video memory, it will be that bright blue color. This means a simple <strong>memset (vidmem, 1, VIDMEM_SIZE)</strong> will effectively clear video display to this color. Cool, huh?</p>
<p>Knowing that the video display determins what color to display for an index is inside of the Color Palette table, we can change what the color is for any palette entry. This allows us to change the colors on screen by just updating the colors in the palette in some way. This is known as <strong>Palette Animation</strong>.</p>
<p>Palette Animation can create alot of really nice looking and cool effects, such as fire animation, icy effects, etc.</p>
<h2 id="mode-0x13">Mode 0x13</h2>
<h3 id="abstract-mode-0x13">Abstract (Mode 0x13)</h3>
<p>Video Mode 0x13 is a standard IBM VGA BIOS mode number for a 256 color 320x200 resolution. It uses a 256 <strong>color palette</strong>, did not have square <strong>pixels</strong>, and allowed access to the <strong>Video Memory</strong> as a <strong>Packed-Pixel Framebuffer</strong>. What this means is that it allowed access to video memory as if it was a linear buffer: Just get a pointer to video memory. pointer[0] = pixel 1, pointer[1] = pixel 2, and so on, assuming <em>pointer</em> is an <em>unsigned char*</em>. This is made possible by specific hardware register settings (The video mode &quot;configuation&quot;) - Standard VGA does not, by itself, provide access to video memory like this.</p>
<p>The important thing here is that video modes define the resolution, how video memory is accessed, and hardware configuation setup for the operation of that mode. Do not worry if you do not understand everything here; we will go into detail when we cover the VGA hardware in a later chapter.</p>
<p>Because video Mode 0x13 is easy to work with (and fast) I decided to use it for the duration of this chapter. Some other modes require experience with the VGA hardware which I am wanting to avoid in this chapter do to its complexity. Dont worry though, I plan on covering some (Like Mode 12h, 640x480x4 color) later on.</p>
<p>Video Mode 0x13 was used alot in the DOS era for video games do to its simplicity to program and speed. It is a video configuation for a 320 width, 200 height pixel resolution with a 256 color palette. It is a planer video memory mode but acts as a <strong>Linear Frame Buffer (LFB)</strong> which makes it easy to program.</p>
<h3 id="color-palette-mode-0x13">Color Palette (Mode 0x13)</h3>
<p>Mode 0x13 has a color palette of 256 colors. Video memory in Mode 0x13 only stores the palette index; the video device will determin what color to render from the installed palette color table. By default, the color table is this:</p>
<p><img src="../../resources/images/mode13h.png" alt="Mode 13h Color Palette"></p>
<p>Here is an example, looking at the above we can see the first color (0) is black, color 1 is blue, color 2 is green, etc. We can write these colors to video display by using these indices in the above lookup table:</p>
<pre><code class="lang-c">unsigned char* p = 0xa0000;

*p = 0; //black pixel
*(p++) = 1; // blue pixel
*(p++) = 4; // red pixel
*(p++) = 255; //white pixel
</code></pre>
<p>Compare the above code to the table above and notice how the indices match with the colors in the palette.</p>
<h4 id="changing-the-palette">Changing the palette</h4>
<p>It is possible to change the palette to whatever colors that you would like. However there is not any easy BIOS interrupt for it (Not without using VBE anyways.) Most of the interrupt calls are used to set or get individual or all palette registers which are inside of the VGA <strong>Digital to Analog Converter (DAC)</strong>. This requires some knowledge of the VGA hardware which I am wanting to avoid this chapter for simplicity (Dont worry, I am planning on covering that soon!) Because of this, I decided to wait on covering palette changing (And mabye palette animations) in a future chapter.</p>
<h2 id="the-video-bios-interface">The Video BIOS Interface</h2>
<p>The VGA Video BIOS Interface is a set of video interrupts (Software interrupt 0x10). Because these are BIOS interrupts, they can only be used in real or v86 modes.</p>
<h3 id="setting-the-video-mode">Setting the video mode</h3>
<h4 id="int-0x10-function-0">INT 0x10 Function 0</h4>
<p>You can set the video mode by calling BIOS interrupt 0x10 function 0:</p>
<ul>
<li>Input
<ul>
<li>AH = 0</li>
<li>AL = video mode</li>
</ul>
</li>
<li>Output
<ul>
<li>AL = video mode flag (Phoenix, AMI BIOS)</li>
<li>AL = CRT Controller (CRTC) mode byte (Phoenix 386 BIOS v1.10)</li>
</ul>
</li>
</ul>
<p>You will see the CRTC alot more in the future as it is one of the controllers that you will need to program if you plan to directly program the video hardware.</p>
<p>This interrupt can set any text or video mode. For example, the following switches to 320x200x8 bit [mode 0x13]: <strong>Please remember that all code samples can be found in the demo.</strong></p>
<pre><code class="lang-armasm">mode13h:
    mov ah, 0
    mov al, 0x13
    int 0x10
    ret&lt;/pre&gt;
</code></pre>
<p>Easy, huh?</p>
<p>The above is all that is needed to get you in a graphics mode. Sure, it will only work in real or v86 mode, but it is as easy as you can get. Dont worry if you do not understand video modes yet; we will cover them a little later.</p>
<h3 id="getting-the-video-mode">Getting the video mode</h3>
<h4 id="int-0x10-function-0xf">INT 0x10 Function 0xF</h4>
<p>You can get the video mode by calling BIOS interrupt 0x10 function 0xF:</p>
<ul>
<li>Input
<ul>
<li>AH = 0xF</li>
</ul>
</li>
<li>Output
<ul>
<li>AH = number of character columns</li>
<li>AL = display mode number</li>
<li>BH = active page</li>
</ul>
</li>
</ul>
<p>This interrupt is an easy one and can be used to obtain the current video or text mode. Dont worry about the &quot;active page&quot; part yet. Dont worry if you do not understand video modes yet; we will cover them a little later.</p>
<pre><code class="lang-armasm">getMode:
    mov ah, 0xf
    int 0x10
    ret
</code></pre>
<h3 id="other-video-bios-interrupts">Other Video BIOS Interrupts</h3>
<h4 id="int-0x10-function-0xbbh1">INT 0x10 Function 0xB/BH=1</h4>
<p>You can set the palette by calling Video BIOS INT 0x10 function 0xB:</p>
<ul>
<li>Input
<ul>
<li>AH = 0xB</li>
<li>BH = 1</li>
<li>BL = Palette ID
<ul>
<li>00h background, green, red, and brown/yellow</li>
<li>01h background, cyan, magenta, and white</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>This interrupt may not be supported on all systems.</p>
<h4 id="int-0x10-function-0xc">INT 0x10 Function 0xC</h4>
<p>You can write a pixel to the display using this interrupt.</p>
<ul>
<li>Input
<ul>
<li>AH = 0xC</li>
<li>BH = Page number</li>
<li>AL = Pixel color
<ul>
<li>if bit 7 set, value is XOR'ed onto screen except in 256-color modes</li>
</ul>
</li>
<li>CX = column</li>
<li>DX = row</li>
</ul>
</li>
<li>Output
<ul>
<li>AL = pixel color</li>
</ul>
</li>
</ul>
<p>This interrupt can only be used in graphics modes.</p>
<h4 id="int-0x10-function-0xd">INT 0x10 Function 0xD</h4>
<p>You can read the pixel by calling Video BIOS INT 0x10 function 0xB:</p>
<ul>
<li>Input
<ul>
<li>AH = 0xC</li>
<li>BH = Page number</li>
<li>CX = column</li>
<li>DX = row</li>
</ul>
</li>
</ul>
<p>This interrupt will only work on graphics modes.</p>
<h2 id="primitives">Primitives</h2>
<h3 id="plotting-your-first-pixel">Plotting your first pixel</h3>
<p><em>&quot;The secret to making any video game is the ability to change the color of a pixel.&quot;</em> - Teej</p>
<p>We have covered alot in this chapter and have yet to draw a pixel on screen. Whats up with that? I decided to close this chapter with the basics of most basic graphics primitives - rendering a pixel to the screen.</p>
<p>Because we are working in Mode 0x13, remember that it acts like a linear frame buffer. So vidmem[0] is the first byte of video memory, vidmem[1] is the second byte. Also, remember that Mode 0x13 uses a byte for each pixel as an index into the Color Palette. This means that, we can write a pixel easy like this:</p>
<pre><code class="lang-c">unsigned char* p = 0xa0000;
p[0] = 1; // blue pixel
</code></pre>
<p>Cool, huh? Thats all that is needed and you have a pixel!</p>
<p>It is easier to think in terms of the <strong>cartesian coordinate system</strong>. In this system, we use coordinates, such as X and Y to represent its location on a 2d graph like this:</p>
<p><img src="../../resources/images/vmem.png" alt="Video memory"></p>
<p>The top-left corner of video memory is at <strong>v = [0,0]</strong> where <strong>v</strong> is a 2d vector. This is the first pixel in video display. The last byte is at <strong>v = [width, height]</strong>. Assuming each coordinate is a pixel, we can come up with a formula that allows us to be able to draw a pixel at any location on screen.</p>
<p>Lets say we start at <strong>v = [0,0]</strong> in the graph above. If we add <strong>width</strong> to our position, we always end up right below where we were. For example, in the above graph, <strong>width = 16</strong>. Assuming we started at the top-left corner, counting 16 to the right, you will find yourself right below (on the next line) from where you started. Because of this, we can calculate <strong>y</strong> by doing <strong>y * width</strong>. Afterwords we can just add <strong>x</strong> (The offset in that line) and we have our formula:</p>
<p><img src="../../resources/images/pixel.png" alt="pixels calculation"></p>
<p>To render a pixel at any <strong>[x,y]</strong> location, we use the formula <strong>x + y * width</strong>. With this, we can create a simple routine like this:</p>
<pre><code class="lang-armasm">;-----------------------;
;   renders pixel
;   cl = color ax = y bx = x
;   es:bp = buffer
;-----------------------;
pixel:
; [x + y * width] = col

    pusha
    mov di, VGA_MODE13_WIDTH
    mul di ; ax = y * width
    add ax, bx ; add x
    mov di, ax
    mov byte [es:bp + di], cl ; plot pixel
    popa
    ret
</code></pre>
<p>es:bp points to the video display, or another buffer that we want to render to. cl is the color index that you want to use, ax is the Y location and bx is the X location.</p>
<h3 id="clearing-the-screen">Clearing the screen</h3>
<p>There are several ways of clearing the screen. This is important as alot of times when switching video modes, you may see alot of garbage on screen.</p>
<p>One method that we can do is just call our pixel routine above <strong>width * height</strong> times. A better method would be to write multiple pixels at once. Knowing, for example, that the size of a pixel in Mode 13h is a byte, we can easily store 2 bytes (2 pixels) in a word size register and use that instead:</p>
<pre><code class="lang-armasm">;---------------------------;
;    clear screen
;    cl = color
;---------------------------;
clrscr:

  pusha
  mov dl, cl    ; dx = 2 pixels
  mov dh, cl

  mov cx, 0
  xor di, di

  .l:
      mov word [es:bp + di], dx ; plot 2 pixels
      inc di ; go forward 2 bytes
      inc di
      inc cx
      cmp cx, (VGA_MODE13_WIDTH * VGA_MODE13_HEIGHT) / 2 ;end of display?
      jl .l

  popa
  ret
</code></pre>
<p>es:bp refers to either video memory or another buffer and cl is the color that you would like to use.</p>
<h2 id="demo">Demo</h2>
<p><img src="../../resources/images/mode13hDem.png" alt="Demo in bochs">
<a href="../../resources/OSDev_tools/DemoGfx1.zip">Demo Download</a></p>
<p>This demo spices what we talked about a little by adding an additional routines: <strong>line</strong>, which renders a horizontal line, and is used to render the rectangles in the demo.</p>
<h2 id="conclusion">Conclusion</h2>
<p>That's all for this chapter!</p>
<p>The next chapter will cover VESA VBE and how we can use it to work with high resolution graphics modes. We will also cover the Super VGA, Bank Switching, and a few more graphics concepts including <strong>Double and Triple Buffering,</strong> and <strong>Page Flipping</strong>. Thats right, we are going high resolution with VBE 😀</p>
<p>We will also be going back to C in the next chapter and cover some more graphics primitives. I still plan on covering VGA hardware however that will be after VBE. VGA hardware is quite overcomplicated; I want to hold off on the more complex topics in graphics and VGA until a little later.</p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/enygmator/BrokenThorn-OS-Dev-Series/blob/master/docfx_base/articles/61_unorganised_tutorial/Z3a.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            <span><strong>Project (v2.0)</strong> created by <a href="https://github.com/enygmator/">@enygmator</a><br>Tutorial authored by <a href="http://www.brokenthorn.com/">BrokenThorn Entertainment Co.</a><br>Generated by <strong>DocFX v2.56.1</strong></span>
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
