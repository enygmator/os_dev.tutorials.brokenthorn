<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Process Management 2 | BrokenThorn OS Dev Tutorials </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Process Management 2 | BrokenThorn OS Dev Tutorials ">
    <meta name="generator" content="docfx 2.56.1.0">
    
    <link rel="shortcut icon" href="../../resources/icons/favicon.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="../toc.html">
    
    <meta property="docfx:rel" content="../../">
    <meta property="docfx:newtab" content="true">
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../resources/images/favicon.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list"></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="process-management-2">Process Management 2</h1>

<h2 id="introduction">Introduction</h2>
<p>Welcome!</p>
<p>In the previous chapter we detailed basic process management topics, including Inter-Process Communication (IPC), protection, resource allocation, Process Control Block (PCB), process execution states, and process address spaces. We have also detailed single tasking support and implementing basic single tasking. This chapter is a continuation of the previous chapter and will go into more detail of the respective topics; with emphasis on multitasking, scheduling, security, and mutual exclusion. In particular, we will cover:</p>
<ol>
<li>Multithreading;</li>
<li>Multitasking;</li>
<li>Init and Idle Process;</li>
<li>Kernel/User Shared Data Space;</li>
<li>Mutual exclusion and Semaphores;</li>
<li>Introduction to Concurrent programming;</li>
<li>Scheduling algorithms;</li>
<li>Introducing to the MP Standard.</li>
</ol>
<p>We will assume that you have read the previous chapter and so this chapter will be more advanced; focusing on real world designs and implementations. Like the previous chapter, we will first dive into the theory behind these topics and then present a demo that will implement complete multi-threading in user land processes. Also note that we only provide a brief introduction to the MP standard; we may cover it in more detail in a later article. Implementing MP support requires proper support for the APIC which is an advanced topic.</p>
<h2 id="process-state-management">Process State Management</h2>
<p>We already talked a lot about processes throughout the series so this will just be a review of process states and process creation. In the previous chapter we implemented a function for creating a process. We will be modifying it in the accompanying demo to create a new task for the process so that it can be properly executed. We need to review state management since it ties closely with the scheduling of processes.</p>
<p>The <strong>state</strong> of the process is the current activity employed by the process. At a minimum, the process can be <strong>created</strong>, <strong>executed</strong>, <strong>ready</strong> to be executed, and <strong>terminated</strong>. Already this gives us four possible states:</p>
<ul>
<li><strong>New</strong>. The process is being created.</li>
<li><strong>Running</strong>. The process is executing.</li>
<li><strong>Ready</strong>. The process is ready to be executed.</li>
<li><strong>Terminated</strong>. The process has completed.</li>
</ul>
<p>This is a good start. However we can do better then this. Let's say that we have some process running, and the process sends a request to read a large file from the disk. However, in a system with multiple processes, the disk may be busy handling the request from that process. Our process needs to <strong>Wait</strong> until the <strong>Input/Output Request</strong> can be completed. For another example, let's say that we have two processes, but they communicate with each other through <strong>signals</strong>. A process would need to <strong>Wait</strong> for a signal to be <strong>raised</strong>. This would be our fifth state:</p>
<ul>
<li><strong>Wait</strong>. The process is waiting to complete an I/O request, exception, or signal.</li>
</ul>
<p>Putting everything together, a process goes through the following states.</p>
<p><img src="../../resources/images/osdev25_a.png" alt="Flowchart of states of process"></p>
<p>The above diagram illustrates the current state model. <strong>New</strong> processes are <strong>admitted</strong> into the system <strong>Ready queue</strong>. When the <strong>Scheduler dispatcher</strong> selects the process to run, the process enters the <strong>Run</strong> state. From here, the process may take any number of state changes. If an <strong>interrupt</strong> or <strong>exception</strong> fires, the <strong>Scheduler Dispatcher</strong> may need to switch to another process which involves moving our process back into the <strong>Ready queue</strong>. If, instead our process tries to read from a file, the process will initiate the <strong>I/O request</strong> and be placed on the <strong>Wait queue</strong> until the request is completed. When the I/O request is satisfied, the process will be placed back into the <strong>Ready queue</strong> to be selected by the <strong>Scheduler dispatcher</strong> again. Finally, at any time while running the process terminates, it will be terminated.</p>
<p>Sometimes it might be helpful to <strong>suspend</strong> a process. This involves taking the process out of memory and storing its state on the disk. This is specifically useful when freeing up system resources and allows other processes with higher priority to run. This requires, at a minimum, two more states:</p>
<ul>
<li><strong>Suspend Ready</strong></li>
<li><strong>Suspend Wait</strong></li>
</ul>
<p>Adding these to our previous diagram, we have the following.</p>
<p><img src="../../resources/images/osdev25_b.png" alt="Modified Flowchart of states of process"></p>
<p>Processes in the <strong>Ready</strong> or <strong>Wait</strong> state may be <strong>Suspended</strong> depending on the resource demand of the system. There can be many more states that you can add to this depending on your design needs, however for most general purpose operating systems, the above state diagram would suffice.</p>
<p>For our purposes, we will only be concerned with the <strong>Ready</strong>, <strong>Run</strong>, and <strong>Terminated</strong> states. However we may also implement the <strong>Wait</strong> state to properly support the <strong>sleep</strong> function in the accompanying demo.</p>
<h2 id="concurrent-programming">Concurrent Programming</h2>
<p>So we looked at process states and state management and process creation. We have also dived deep into a process in memory with the previous chapter. The final topic that we need to dive into is <em><strong>multitasking</strong></em>. The heart of multitasking is the <strong>Scheduler dispatcher</strong> which we will cover in the next section. The Scheduler dispatcher is responsible for moving processes between states and schedule processes for execution. This is why we covered those first – we will be using them in that section later on. Before moving on to the scheduler however, we need to take a closer look at what happens with multitasking when there are multiple <strong>threads of execution</strong>. When two threads or processes run <em><strong>concurrently</strong></em> and share some data with each other, it becomes critical to synchronize the activities between the two threads of execution.</p>
<p><em><strong>Concurrency</strong></em> means that the current state of the process is not known. When multiple processes run along side each other and share data with each other, they are said to be running <em><strong>concurrently</strong></em>. <em><strong>Concurrent programming</strong></em> defines the set of techniques used to <strong>synchronize</strong> access to <strong>shared resources</strong> between concurrent processes or threads.</p>
<h3 id="critical-section-problem">Critical Section Problem</h3>
<p>On single core systems, the operating system will allocate a small amount of time for execution for each process. The system switches rapidly between the different processes running concurrently. Processes may be interrupted at any time. In addition, systems that support <strong>parallel execution</strong> may execute instructions from different processes at the same time.</p>
<p>To see the problem of current programming, consider two processes with the following instructions.</p>
<p>Process A:</p>
<pre><code class="lang-armasm">mov eax, [count]
inc eax
mov [count], eax
</code></pre>
<p>Process B</p>
<pre><code class="lang-armasm">mov ebx, [count]
dec ebx
mov [count], ebx
</code></pre>
<p>If we are to execute these processes concurrently, they would be <em><strong>interleaved</strong></em> in some order when the scheduler switches between the two processes. There are many different ways the processes may be interleaved, one way might be:</p>
<pre><code class="lang-armasm">mov eax, [count]
inc eax
mov ebx, [count]
dec ebx
mov [count], eax
mov [count], ebx
</code></pre>
<p>If <strong>count</strong> is shared between the two different processes, you might notice a big problem here. Because there is no control over the <strong>order of execution</strong>, we cannot insure that the value of count is valid because we may get different results depending on <em>when</em> the scheduler decides to switch between the two processes. The outcome depends on who reads and writes the variable first. What we have is a <strong>race condition</strong>.</p>
<p>To combat the race condition, we need to <strong>guard</strong> the variable while it is being used by another process. We need to <strong>synchronize</strong> the two processes in some way. This is a part of the <strong>critical section problem</strong>.</p>
<p>The problem is <em>compounded</em> on systems with multiple processors since the current execution state and current instruction streams are interleaved while executing a <em>single</em> process.</p>
<p><strong>The Problem.</strong></p>
<p>We need a method to control synchronization of a process that executes concurrently. When a critical section request is made, we must insure that only <em>one</em> processor executes the code within the critical section until it completes. Farther, we must insure that other processes and threads do not execute while we enter the critical section.</p>
<p><strong>The Criteria.</strong></p>
<ul>
<li><strong>Mutual Exclusion.</strong> When a process is executing in a critical section, no other process is executing in a critical section.</li>
<li><strong>Progress</strong>. Processes do not wait indefinitely to enter their critical section.</li>
<li><strong>Bounded Waiting.</strong> The amount of time between making the request to enter its critical section and actually entering it must be bounded.</li>
</ul>
<h3 id="semaphores">Semaphores</h3>
<p>Sow how do we implement <strong>mutual exclusion</strong>? We need some form of <strong>cooperation</strong> between the two processes. <strong>If process A is operating on a shared resource, and process B needs access to it, we want process B to wait</strong>. However, <strong>once process A is done with the resource, we want it to signal that Process B can now use that resource</strong>. Thus only one process can ever use the shared recourse at any given time. This is <em><strong>mutual exclusion</strong></em>.</p>
<p>What we can do is introduce another variable to keep track of whether or not the resource is currently being used or not. This variable is called a <em><strong>lock</strong></em>. We can then use this lock to keep track of the other resource.</p>
<ul>
<li>If the lock is 1, the resource is in use by some other process.</li>
<li>If the lock is 0, the resource is free for use.</li>
</ul>
<p>This type of lock has a special name. It is called a <em><strong>mutex</strong></em>. The mutex has only two values and is also called a <em><strong>binary semaphore</strong></em>. Recall what we need to do: we need one process to <em><strong>wait</strong></em> and the other process to <em><strong>signal</strong></em>. These are the basic functions we will be using throughout this chapter.</p>
<pre><code class="lang-c">atomic Wait (Semaphore S) {
while (S &lt;= 0)
  Place process on S.Queue and block.
  S--;
}
atomic Signal (Semaphore S) {
  S++;
}
</code></pre>
<p>The <strong>mutex</strong> is just a *<strong>binary semaphore</strong> _with values of 0 or 1 only. <em><strong>Semaphores</strong></em> are generalized locks and are not restricted (that is, whereas the mutex only has two values, general semaphores do not.) Also notice the atomic keyword in the above code. This implies that the code will never be interrupted when it is executed. That is, it is <em><strong>guaranteed</strong></em> to run as a block of code on a single processor in the correct order. <em><strong>They are to be treated as a single unit</strong></em> (hence are called <strong>atomic</strong> operations.)</p>
<p>Unfortunately, it isn't quite as simple as what we shown above. <strong>Atomic operations are hardware dependent</strong> and so we need some assistance from the processor to make it work. More specifically, we need to make use of the <strong>LOCK</strong> instruction prefix. We will discuss this in more detail later as we implement these primitives into actual code.</p>
<p>For now, we believe that it is best to see some examples of using semaphores since they can be difficult when first introduced. It is important to get some practice with using them since you will be using them a lot if you ever plan to completely support multiprocessing.</p>
<p><strong>Example:</strong> We opened up this section by showing how the instruction flow can get interleaved as we swap between different processes. The problem was that both of the processes can be executed at any time, and because they share a resource, there was no way to verify the integrity of the resource. We can fix that with semaphores. Assuming count is a global variable that is shared by two processes, we can use semaphores to synchronize access to it. Note that signal and wait are atomic operations.</p>
<p>Process A:</p>
<pre><code class="lang-c">count++;
signal (s);
</code></pre>
<p>Process B:</p>
<pre><code class="lang-c">wait (s);
count--;
signal (s);
</code></pre>
<h3 id="spinlocks">Spinlocks</h3>
<p>Mutual exclusion is the first criteria for a solution to the critical section problem. This means that, when one process enters a critical section, no other processes can enter a critical section. To implement this functionality, we need some method of implementing an <strong>atomic</strong> operation that can guarantee mutual exclusion. One idea is to use a simple variable to act as a lock. If the lock is 1, some process is inside of the critical section. So the first idea is,</p>
<p><strong><code>int lock=0;</code></strong></p>
<p>Process A:</p>
<pre><code class="lang-c">while(1) {
  if (!lock)
    lock = 1;
  do_something();
  lock=0;
}
</code></pre>
<p>Process B:</p>
<pre><code class="lang-c">while(1) {
  if (!lock)
    lock = 1;
  do_something();
  lock=0;
}
</code></pre>
<p>Pretty simple. The lock starts at 0, so whatever process runs first will detect this and set the lock. When its done, it releases the lock so the second process can now use it. This would work somewhat, but there is still a big problem. Let's say that process A detects that the lock is 0 but gets interrupted by process B before process A has a chance to set the lock. So process B detects the lock is also 0 and now sets it. So if process B gets interrupted somewhere in <strong>do_something</strong>, process A will continue executing – as if the lock was still 0! And so both processes can still enter the same critical section (in this example, the critical section is the call to <strong>do_something</strong>) at the same time if the processes get interrupted when trying to read and lock the lock variable itself. This seems like a small error, but it can quickly propagate and will happen quite a lot.</p>
<p>So the problem here is that we cannot guarantee that accessing and setting the lock can be done without getting interrupted. The operation is not <em><strong>atomic</strong></em>.</p>
<p>To be able to visualize what can happen without actual atomic operations, let's say that we have two threads. The first thread displays characters a-z and the second thread displays numbers 0-9. They run concurrently using the scheduler that we develop later on. Here are the threads,</p>
<p>Process A:</p>
<pre><code class="lang-c">void task_1() {
  char c='a';
  while(1) {
    DebugPutc(c++);
    if (c&gt;'z') c='a';
  }
}
</code></pre>
<p>Process B:</p>
<pre><code class="lang-c">void task_1() {
  char c='0';
  while(1) {
    DebugPutc(c++);
    if (c&gt;'9') c='0';
  }
}
</code></pre>
<p>As these two tasks run concurrently, the output will become an interleaved mess. The reason is that both processes are reading and writing from shared resources without care. Even if we were to introduce a lock as we discussed above, the output wouldn't be much better. In this example, the shared resources are video memory and the global variables used by <strong>DebugPutc</strong> which is responsible for cursor positioning and scrolling. As one process reads the current x or y position or prepares to scroll, it may be interrupted and the position and other global variables can be mangled without the first process ever knowing.</p>
<p><img src="../../resources/images/demo25_problem.png" alt="Sample without semaphores. Notice how the output is a mess."><br>
Sample without semaphores. Notice how the output is a mess.</p>
<p>So to fix this, we need something more then a simple lock. Our direction is good – but we need hardware support. If there was a method to make it so that we can test and set a lock variable in one single operation with the guarantee that it will never be interrupted (so it is <strong>atomic</strong>) we can finally satisfy the <strong>mutual exclusion</strong> criteria.</p>
<p>One such hardware primitive is the <strong>LOCK</strong> instruction prefix. This prefix locks the system bus from reads and writes while the instruction is being performed. Because the data bus is locked, it is guaranteed to be atomic. So a simple <strong>LOCK XCHG</strong> or <strong>LOCK BTS</strong> can be used when setting and testing a lock variable. For example,</p>
<pre><code class="lang-c">inline void acquire(int* lock) {
  _asm{
    mov eax,[lock]
a:  lock bts [eax], 0
    pause
    jc a
  }
}

inline void release(int* lock) {
  _asm{
    mov eax, [lock]
    mov [eax], 0
  }
}
</code></pre>
<p>We can now call these functions from to acquire and release the lock.</p>
<p>Process A:</p>
<pre><code class="lang-c">void task_1() {
  char c='a';
  while(1) {
    acquire(lock);
    DebugPutc(c++);
    release(lock);
    if (c&gt;'z') c='a';
  }
}
</code></pre>
<p>Process B:</p>
<pre><code class="lang-c">void task_2() {
  char c='a';
  while(1) {
    acquire(lock);
    DebugPutc(c++);
    release(lock);
    if (c&gt;'z') c='a';
  }
}
</code></pre>
<p>And we get the desired result.</p>
<p><img src="../../resources/images/demo25_fix.png" alt="Running Sample with spinlocks. Note how the display is now nicely in order."><br>
Running Sample with spinlocks. Note how the display is now nicely in order.</p>
<h2 id="classic-concurrency-problems">Classic Concurrency Problems</h2>
<h3 id="producer--consumer-problem-bounded-buffer-problem">Producer / Consumer Problem (Bounded Buffer Problem)</h3>
<p>This is the first classic concurrency problem we will look at. Suppose that we have two independent processes, one called the <strong>producer</strong> and the other called the <strong>consumer</strong>. Let's also assume that there is a shared buffer being used by both of the processes. The producer is responsible for putting data into the buffer and the consumer is responsible for taking data out. This is the basic setup for the classic <strong>Producer/Consumer Problem</strong> also known as the <strong>Bounded Buffer Problem</strong>. The problem is that we need to make sure that the producer does not add data to the buffer if its already full and the consumer does not try to remove data from a buffer that is empty. The problem gets more interesting when there are multiple producers and consumers.</p>
<p><strong>Example:</strong> This is a solution to the Bounded Buffer problem. This assumes a single producer and consumer running concurrently.</p>
<pre><code class="lang-c">Semaphore c = 0;
Semaphore s = BUFFER_SIZE;
</code></pre>
<p>Producer:</p>
<pre><code class="lang-c">while (true) {
   item = produce ();
   wait(s);
   write(item);
   signal(c);
}
</code></pre>
<p>Consumer:</p>
<pre><code class="lang-c">while (true) {
   wait(c);
   item = read();
   signal(s);
   consume(item);
}
</code></pre>
<h3 id="readers--writers-problem">Readers / Writers Problem</h3>
<p>The classic R<strong>eaders/Writers problem</strong> is when an object is shared among many processes such that there are two types of processes – <strong>readers</strong> and <strong>writers</strong>. <strong>Readers</strong> read the shared data but never modify it. <strong>Writers</strong> can read data and modify it. <strong>Many readers may read the data concurrently</strong>.</p>
<p><strong>Example:</strong> There are many different solutions and versions of this problem, this is one of them. Note that we use two semaphores here so that we can allow multiple readers at the same time.</p>
<pre><code class="lang-c">Semaphore c = 1;
Semaphore s = 1;
int count = 0;
</code></pre>
<p>Writer:</p>
<pre><code class="lang-c">while (true) {
   wait(c);
   write();
   signal(c);
}
</code></pre>
<p>Reader:</p>
<pre><code class="lang-c">while(true) {
  wait(s);
  count++;
  if (count == 0)
    wait(c);
  signal(s);
  read();
  wait(s);
  count--;
  if (count == 0)
    signal(c);
  signal(s);
}
</code></pre>
<h2 id="inter-process-communication">Inter-Process Communication</h2>
<p><strong>Inter-Process Communication (IPC)</strong> is the technique supported by operating systems that permit processes to signal and share data with other running processes. There are many different types of techniques for implementing IPC protocols, we will introduce some of the most commonly used ones here.</p>
<h3 id="pipes">Pipes</h3>
<p>Pipes are a basic technique that uses a circular buffer to store the data between a producer and consumer. The producer writes data to the buffer and the consumer reads from it. There can be multiple producers and consumers of the data. There are two types of pipes, anonymous pipes and named pipes. <strong>Named pipes</strong> are given a name and appear as a file object in the virtual file system. Any process in the system can <strong>open</strong> named pipes. <strong>Anonymous pipes</strong> can only be opened by child processes that inherit it from the parent.</p>
<p>The operating system must provide functionality for <strong>storing</strong> the data stream that is shared between the consumers and producers, <strong>reading</strong> and <strong>writing</strong> the stream, and <strong>blocking</strong> processes that attempt to read from the pipe when there is no data to read. The operating system must <strong>synchronize</strong> the reading and writing using the mutual exclusion techniques that we discussed above. This is usually done using a <strong>First-In-First-Out (FIFO) circular buffer</strong> and using <strong>semaphores</strong> to synchronize access to it when reading and writing it.</p>
<p>Pipes are <strong>file system objects</strong>. When you <strong>Open</strong> a pipe, you will get a <strong>File Descriptor</strong> pointer back. So you can use the file <strong>Read</strong> and <strong>Write</strong> methods to read and write to the pipe as if it were a file. <strong>Open file handles are inherited by child processes</strong>, and so pipes are also inherited.</p>
<p>Pipes can be managed just like file system descriptors. The <strong>Process Parameter Block</strong> stores a pointer to a <strong>Process Handle Table</strong> that stored all open references to file descriptors, pipes, and other system objects. They can also be trivial to implement on systems that already support <strong>device files</strong>.</p>
<h3 id="message-passing">Message Passing</h3>
<p>The basic idea is simple enough – a producer sends a <strong>message</strong> and a consumer takes it. There might be additional problems depending on if we want to support <strong>synchronized</strong> or <strong>asynchronous</strong> message passing. We also must think about how to <strong>store</strong> the messages, where they should be <strong>managed</strong>, the <strong>format</strong> of the messages, and how to verify that messages are delivered in the expected format to the expected process.</p>
<p>So, what exactly is a <em>message</em>? Messages are whatever the process wants it to be. The consumer and producer must agree on some type of <strong>protocol</strong> for how to interpret the message. They both need to know the <strong>data structure</strong> of the message. From the operating system side, the OS does not care about the format of the data – <strong>unless its an OS defined message which is typical of microkernels</strong>.</p>
<p>The operating system needs to implement support to <strong>Send</strong> and <strong>Receive</strong> messages at a minimum.</p>
<h4 id="synchronous-message-passing">Synchronous Message Passing</h4>
<p>For Synchronous message passing, we need at a minimum two functions. Assuming <strong>J</strong> and <strong>K</strong> are process identifiers (PID)'s,</p>
<ul>
<li>send(J, message)</li>
<li>receive(K, &amp;message)</li>
</ul>
<p>The producer calls <strong>send</strong> to post a message. With synchronous message passing, the producer gets put in the <strong>suspended queue</strong> until <strong>J</strong> calls <strong>receive</strong> to get the message. When <strong>J</strong> calls <strong>receive</strong>, the operating system can copy the message sent to <strong>J</strong> directly and resume <strong>J</strong>. The operating system can then put the producer back on the <strong>waiting queue</strong> so that it can be executed by the scheduler. Synchronous message passing does not require a message queue since only one (the producer or consumer) will ever be running at the same time (the other would be <strong>suspended</strong> or <strong>waiting</strong>.)</p>
<h4 id="asynchronous-message-passing"><strong>Asynchronous Message Passing</strong></h4>
<p>Asynchronous message passing also needs a minimum of two functions,</p>
<ul>
<li>send(J, message)</li>
<li>receive(K, &amp;message)</li>
</ul>
<p>The producer calls <strong>send</strong> to post a message and the consumer calls <strong>receive</strong> to obtain the message. With asynchronous message passing, the operating system maintains a <strong>message queue</strong> per process. Producers can <strong>send</strong> messages at any time and will not be suspended. Messages are copied to the end of the message queue. The consumer can then <strong>receive</strong> the message from the front of the message queue. The message queue itself is allocated in <strong>kernel memory</strong>; a dedicated pointer in the Process Control Block points to the queue.</p>
<p>We now have an interesting question. With <strong>synchronous message passing</strong>, when the process calls <strong>receive</strong> and there is no process that sent any message, the process gets suspended until another process calls <strong>send</strong>. With <strong>asynchronous message passing</strong>, we have two options:</p>
<ul>
<li>We can <strong>suspend</strong> the process that called <strong>receive</strong> or,</li>
<li>We can have <strong>receive</strong> return a status code and just continue <strong>running</strong> the current process.</li>
</ul>
<p>It turns out that the better approach is to offer a few more functions,</p>
<ul>
<li>send(process, message)</li>
<li>receive(process, &amp;message)</li>
<li>sendrec(process, &amp;message)</li>
<li>notify(process, message)</li>
</ul>
<h3 id="shared-memory">Shared Memory</h3>
<p>When we map the same physical frames into the virtual address spaces of two or more processes, it is <strong>shared</strong> among those processes. Both processes would be able to read or write to the same pages (depending on the <strong>security attributes</strong> set when mapping pages. (For example, you can map the physical frames as read/write for process A but as read-only for process B.) Operating systems typically provide support of shared memory through <strong>memory mapped files</strong>. Under Windows, for example, you would first call <strong>CreateFile</strong> or <strong>OpenFile</strong> on a named memory mapped file object followed by <strong>MapViewOfFile</strong> which maps the region of memory into the process address space and returns a pointer to it.</p>
<h2 id="scheduling">Scheduling</h2>
<p>The scheduler is responsible for the allocation of system resources. System resources include the CPU, memory, and system devices. There are typically many schedulers, however they tend to fall under three categories: <strong>short term</strong>, <strong>medium term</strong>, and <strong>long term</strong>.</p>
<ol>
<li><strong>Long term schedulers</strong> are responsible for admitting processes into the system and terminating them.</li>
<li><strong>Medium term schedulers</strong> are responsible for suspending and resuming processes.</li>
<li><strong>Short term schedulers</strong> are responsible for allocating CPU time and dispatching processes.</li>
</ol>
<p>We will be primarily discussing the short term scheduler in this section since it is a core component to implementing a multitasking system. So, our goal here for the demo is to create a <strong>short term scheduler</strong>.</p>
<h3 id="scheduling-algorithms">Scheduling Algorithms</h3>
<p>There are many different algorithms that we can use, some more complicated then others. While we will provide an introduction to the more common algorithms, we will be sticking with the <strong>Round Robin</strong> approach to keep the demo simple.</p>
<h4 id="first-come-first-serve">First Come First Serve</h4>
<p>In <strong>First Come First Serve (FCFS)</strong>, jobs are executed as they come. The algorithm is as simple as its name implies; the scheduler selects the first job and lets it run. Then the second. Then the next, and so on. The algorithm cycles through the jobs in the Ready Queue in the order that they came in. New jobs are not started until the previous one terminates. It is not very well suitable for preemptive multitasking.</p>
<p><strong>Example:</strong> In the following example, P1 arrives at time 0, P2 arrives at time 1, and P3 arrives at time 2. these processes are placed in the Ready queue to be executed. P1 is the first job, so the algorithm selects it to be run. P2 is selected next, but only after P1 is completed. P2 does not get selected until time=5.</p>
<table>
<thead>
<tr>
<th>Process</th>
<th>Arrive</th>
<th>Run time</th>
<th>Service time</th>
</tr>
</thead>
<tbody>
<tr>
<td>P1</td>
<td>0</td>
<td>5</td>
<td>0</td>
</tr>
<tr>
<td>P2</td>
<td>1</td>
<td>3</td>
<td>5</td>
</tr>
<tr>
<td>P3</td>
<td>2</td>
<td>8</td>
<td>8</td>
</tr>
</tbody>
</table>
<h4 id="shortest-job-first">Shortest Job First</h4>
<p>In the <strong>Shortest Job First (SJF)</strong> algorithm, the system must have a way to know the amount of time necessary for each job to execute. The algorithm selects the next job from the <strong>Ready Queue</strong> to execute that has the smallest time delta. This algorithm suffers from the problem of <strong>process starvation</strong>. Jobs can be left in the <strong>Ready Queue</strong> when jobs of smaller time deltas are given priority. Since this example is very similar to the <strong>FCFS algorithm</strong> discussed above and is almost never implemented in practice due to its requirement of calculating time deltas (your software needs to be an oracle to know beforehand how long processes will execute) we do not think another example is needed.</p>
<h4 id="priority-queue">Priority Queue</h4>
<p>The system can assign each job a <strong>priority number</strong>. Jobs with higher priority are then selected first. This is the basic idea behind <strong>priority scheduling algorithms</strong>. How priority is determined is up to the designer. Similarly, how to handle the case when two priority are the same is up to the designer. One idea is to have a default priority and make it user adjustable. When two priorities are the same, we can use <strong>FCFS</strong> or <strong>SJF</strong> to decide which one to use. Another idea is to calculate priorities based on a <strong>protocol</strong>. The protocol could be assigned by a system administrator or calculated using some measurement of system resources and memory constraints. It is more often common to see priorities used alongside other scheduling algorithms as we will see later on.</p>
<p>To summarize though, just select the job from the <strong>Ready Queue</strong> that has the highest priority. Like with <strong>SJF</strong>, this algorithm suffers from <strong>process starvation</strong> since processes with higher priorities can starve out processes with lower priorities.</p>
<h4 id="round-robin">Round Robin</h4>
<p>The system gives each process a time slice to run called a <strong>quantum</strong>. The system then <strong>preempts</strong> the currently executing process to allow another process to run. Processes are selected in the order that they appear in the <strong>Ready Queue</strong>. Because all processes are allowed to run, this algorithm does not starve any processes. The system is responsible for <strong>context swapping</strong> in order to save and restore the <strong>execution state</strong> of processes as they are selected to run. We will cover <strong>context swapping</strong> later when we cover <strong>multitasking</strong>.</p>
<p><strong>Example:</strong> Given processes P1, P2, P3 and a time quantum of 5, the Round Robin (RR) algorithm first selects P1 to run. After the quantum time is up, the system preempts P1. P1 is moved to the back of the Ready Queue. The system saves the context of P1. The algorithm selects P2 and the system performs a context switch. P2 can now execute.</p>
<table>
<thead>
<tr>
<th>Process</th>
<th>P1</th>
<th>P2</th>
<th>P3</th>
<th>P1</th>
<th>P2</th>
<th>P3</th>
</tr>
</thead>
<tbody>
<tr>
<td>Quantum=5</td>
<td>0</td>
<td>5</td>
<td>10</td>
<td>15</td>
<td>20</td>
<td>25</td>
</tr>
</tbody>
</table>
<h4 id="multilevel-queue">Multilevel Queue</h4>
<p>Instead of using one <strong>Ready Queue</strong> to decide what to run next, why not use <strong>multiple</strong>? The idea is that we can get the both worlds of privileged levels and another scheduling algorithm by combining them into a <strong>multilevel queue</strong>.</p>
<p>The basic idea is that we would have <strong>multiple queues</strong>. And these queues are for <strong>different priorities</strong>. For example, <strong>if you have 5 priority levels, you would have 5 queues</strong>. The algorithm would first select a job to run based on priority from the highest priority queue. If the queue has multiple jobs in it, it uses another algorithm (like <strong>RR</strong>) to decide what to run. You can also use different scheduling algorithms for the different priority queues. This algorithm has the potential for <strong>starving processes</strong> however for the same reason <strong>priority scheduling</strong> does. So we have a great algorithm here, but what can we do to prevent <strong>starving processes</strong>?</p>
<h4 id="multilevel-feedback-queue">Multilevel Feedback Queue</h4>
<p>The <strong>Multilevel Feedback Queue</strong> is a modification of the <strong>multilevel queue</strong> to prevent <strong>process starvation</strong>. The problem with the multilevel queue was that, when a process of some priority L is inserted into queue L, we can starve the process by just submitting new jobs where the priority is greater than L. To prevent this, what we can do is <em><strong>change the priority of the process</strong></em>. So we can move processes from one priority queue into another.</p>
<p>In our example above, the process with priority L would be moved to a higher priority queue after some time passes. This will continue until the process reaches the highest priority queue. Thus the process is never starved out. We can also lower the priority of jobs by moving them into lower priority queues which might be useful when important system tasks need to run. The difficulty of implementing multilevel feedback queues is determining <em>when</em> processes should be moved. This is the most common algorithm in use by modern operating systems today.</p>
<p><strong>Example:</strong> The following is an example of a multilevel queue. Here we have three queues, system processes have the highest priority and applications have the lowest priority. Different scheduling algorithms can be used on each of the different queues to select jobs from them. The scheduler selects the highest priority non-empty queue. It then uses another algorithm (such as FCFS or RR) to select a job from that queue. In multilevel feedback queues, the system can move processes between different queues. For example, we can move jobs from L3 then L2 then L1 over time, thereby raising its priority so it can run. Thus no process starvation.</p>
<table>
<thead>
<tr>
<th>Queue Level</th>
<th>Priority Queue</th>
</tr>
</thead>
<tbody>
<tr>
<td>L1</td>
<td>System Processes</td>
</tr>
<tr>
<td>L2</td>
<td>Batch Jobs</td>
</tr>
<tr>
<td>L3</td>
<td>Applications</td>
</tr>
</tbody>
</table>
<h2 id="multitasking">Multitasking</h2>
<p>We have covered a <strong>lot</strong> of material throughout this chapter. And at long last, we can finally get to the main focus of this chapter, <strong>multitasking</strong>. We will be putting everything together into code.</p>
<p>We first covered <strong>process state management</strong> because the <strong>scheduler</strong> and <strong>multitasking</strong> component need to able to select and move processes between different <strong>states</strong>. For example, the <strong>scheduler</strong> often needs to switch processes from <strong>Ready</strong> to <strong>Running</strong>. If you plan to support more advanced paging techniques (such as <strong>page swapping algorithms</strong>), you will need to be able to switch processes to and from a <strong>Suspended</strong> state. The system needs to be able to differentiate between a <strong>Suspended</strong> process and one that is still in memory awaiting a completion signal. Both processes have a <strong>Process Control Block (PCB)</strong> and uses system resources, however <strong>Suspended</strong> processes aren't using memory. We also needed a way to pause processes. We did this by introducing a <strong>Wait</strong> state. As you can see, state management is a critical component to implementing multitasking. This is why we covered this first.</p>
<p>The next thing we looked at was <strong>Process Creation</strong>. We looked in more detail about how it is used with state management. In <strong>Chapter 24</strong>, we implemented a <strong>CreateProcess</strong> function. Recall, that our function loaded a <strong>Portable Executable (PE)</strong> image into memory, mapped it into the virtual address space, and executed it in user mode. We will be building off of this function in this section to create a new process, and add it to the <strong>Ready queue</strong> to be selected by the <strong>Scheduler</strong>.</p>
<p>Then we looked at an introduction to <strong>concurrent programming</strong>. Topics included the <strong>Critical Section</strong> problem, <strong>Mutual Exclusion</strong>, and <strong>Semaphores</strong>. <strong>Concurrency</strong> happens when multiple processes and threads run <em><strong>asynchronously</strong></em>. Concurrent programming provides techniques that we can use to <em>synchronize</em> communication between <em>asynchronous</em> processes. Concurrent programming is <em><strong>hard</strong></em> – there is no <em>right</em> way to go about it. If you use concurrency, you can <em>guarantee</em> that your code has bugs – most of which may never surface for years or decades. We introduced concurrent programming since the topic of this chapter is multitasking. Since shared resources tie close to multitasking (typically in the form of shared libraries, signals, and message passing), we included a brief introduction to it here.</p>
<p>We then looked at an introduction to <strong>Inter-Process Communication (IPC)</strong>. IPC plays a critical role in all but the simplest of operating systems. And systems that support IPC with multitasking require the concurrent programming techniques discussed in this chapter. You have already been using a form of IPC through the use of <strong>system calls</strong>.</p>
<p>Finally we covered <strong>scheduling algorithms</strong>. The Scheduler is the heartbeat of the operating system. It is responsible for selecting processes for running and is a core algorithm in the multitasking system.</p>
<p>Now, <em>finally</em>, we will be putting things together as we dive into the world of multitasking operating systems.</p>
<p>As you recall, there are three types of multitasking:</p>
<ol>
<li>Preemptive</li>
<li>Non-Preemptive</li>
<li>Cooperative</li>
</ol>
<p>We will focus on preemptive multitasking.</p>
<h3 id="the-plan">The Plan</h3>
<p>We will be using the <strong>Round Robin (RR)</strong> scheduling algorithm. This algorithm requires us to be able to allocate a <strong>quantum</strong> as a resource to the process being selected. So we'll need a <strong>clock</strong>. The system has many different types of clocks:</p>
<ol>
<li>Programmable Interval Timer (PIT)</li>
<li>Advanced Programmable Interrupt Controller (APIC) timer</li>
<li>Real Time Clock (RTC)</li>
<li>High Performance Event Timer (HPET)</li>
<li>etc.</li>
</ol>
<p>For the purposes of the demo, we will be sticking with the PIT since it has been covered and already supported. So we have our scheduling algorithm and clock that we will be using. In Chapter 24, we introduced the <strong>Process Control Block (PCB)</strong> and <strong>Thread Control Block (TCB)</strong>. We will expand the TCB to include information needed to store the current thread state and switch from user mode to kernel mode.</p>
<pre><code class="lang-c">typedef struct _thread {
   uint32_t    esp;
   uint32_t    ss;
   uint32_t    kernelEsp;
   uint32_t    kernelSs;
   struct _process*  parent;
   uint32_t    priority;
   int         state;
   ktime_t     sleepTimeDelta;
}thread;
</code></pre>
<p>We will need some lower level stuff to create the task associated with a thread. The <strong>stack</strong> stores the current <strong>register context</strong>. We will be storing the register context on the stack pointed to be the <strong>esp</strong> field in the above structure. The <strong>scheduler</strong> is responsible for <strong>creating</strong> tasks, <strong>managing</strong> tasks, and <strong>switching</strong> tasks. We will look at each of these in more detail in the following sections. As always, all sample code is used in the demo program at the end of this chapter.</p>
<h3 id="the-ready-queue">The Ready Queue</h3>
<p>We first need a place to store these tasks. Tasks should be dynamically allocated from a non-paged pool by the kernel memory allocator. However, since the series does not implement a kernel allocator, we are limited to using an array for our implementation. Using a circular queue, we can implement the <strong>First-In-First-Out</strong> functionality required for <strong>Round Robin</strong> scheduling. The idea is so that we can move to the next task by simply removing the top element of the queue and pushing it to the back. So the new task would become the top of the queue.</p>
<pre><code class="lang-c">thread   _readyQueue  [THREAD_MAX];
int      _queue_last, _queue_first;
thread   _idleThread;
thread*  _currentTask;
thread   _currentThreadLocal;

/* clear queue. */
void clear_queue() {
    _queue_first = 0;
    _queue_last  = 0;
}

/* insert thread. */
bool queue_insert(thread t) {
    _readyQueue[_queue_last % THREAD_MAX] = t;
    _queue_last++;
    return true;
}

/* remove thread. */
thread queue_remove() {
    thread t;
    t = _readyQueue[_queue_first % THREAD_MAX];
    _queue_first++;
    return t;
}

/* get top of queue. */
thread queue_get() {
    return _readyQueue[_queue_first % THREAD_MAX];
}
</code></pre>
<p>For our example, we only implement a single queue for ready tasks. Tasks can be removed and added at any time by shuffling the queue around. Notice the *<strong>currentTask</strong> pointer. For Chapter 25, this pointer always points to *<strong>currentThreadLocal</strong> which stores a local copy of the currently executing thread. Our ISR will use the pointer to save and restore the thread state. We will look at the ISR in the next section.</p>
<h3 id="the-interrupt-service-routine-isr">The Interrupt Service Routine (ISR)</h3>
<p>Alright, so our first task is to somehow get the scheduler called whenever a timer even triggered. Recall that hardware interrupts are raised by the Interrupt Controller, in our case, the legacy <strong>Programmable Interrupt Controller (PIC)</strong>. There are of course others (such as <strong>Advanced PIC (APIC)</strong> used with <strong>MultiProcessor (MP)</strong> and inter-CPU IRQ's) however we supported the legacy PIC interface only for the series in order to keep things simple. The PIC raises a signal to the CPU when a hardware device sends it to the PIC, such as the IR#0 signal sent from the PIT. The PIC then notifies the CPU by raising another signal, in this case the IRQ line on the CPU. What IRQ that gets called depends on how we programmed the PIC. Recall that we programmed the PIC to map IR#0 to ISR 33. What this means is that, whenever the PIT fires, the CPU stops executing the current code, pushes the return cs, eip, and flags on the current stack, and then calls the ISR that we installed in the <strong>Interrupt Descriptor Table (IDT)</strong>, that is, <strong>IDT[33]</strong>.</p>
<p>In short, we already installed our timer ISR to interrupt vector 33. We did this back when setting up protected mode. It was needed in order for us to enable hardware interrupts. That is fine and all, but what we want to do is <em><strong>override</strong></em> it.</p>
<p>We do this through <em><strong>interrupt chaining</strong></em>. We introduced interrupt chaining in an earlier chapter, however we never really put it into practice. Until now, that is. What we need to do is to get the old ISR, install our own. Lets do that now,</p>
<pre><code class="lang-c">/* register isr */
old_isr = getvect(32);
setvect (32, scheduler_isr, 0x80);
</code></pre>
<p>Simple enough. We implemented <strong>getvect</strong> and <strong>setvect</strong> back when we talked about the <strong>IDT</strong>. We install it to <strong>IDT[32]</strong> because that is where the <strong>PIT</strong> ISR was. So what this does is save it in <strong>old_isr</strong> and install a new ISR, <strong>scheduler_isr</strong>.</p>
<p>So, with the above in mind, every time the PIT fires, <strong>scheduler_isr</strong> will be called instead. Now for the hard part – writing the ISR. Consider what the ISR needs to do and when it can be called. <em><strong>The ISR can be called at any time</strong></em>. However, <em><strong>it is always called when a task is running</strong></em>. All we need to do is save the current register state and call the scheduler. Do not forget to send the <strong>End-Of-Interrupt (EOI)</strong> to the PIC.</p>
<p>We will first present the ISR implemented for the demo, and then we will break it piece by piece to cover the details of what its doing below.</p>
<pre><code class="lang-armasm">__declspec(naked) void _cdecl scheduler_isr () {
    _asm {
    ;
    ; clear interrupts and save context.
    ;
    cli
    pushad
    ;
    ; if no current task, just return.
    ;
    mov eax, [_currentTask]
    cmp eax, 0
    jz  interrupt_return
    ;
    ; save selectors.
    ;
    push ds
    push es
    push fs
    push gs
    ;
    ; switch to kernel segments.
    ;
    mov ax, 0x10
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax
    ;
    ; save esp.
    ;
    mov eax, [_currentTask]
    mov [eax], esp
    ;
    ; call scheduler.
    ;
    call scheduler_tick
    ;
    ; restore esp.
    ;
    mov eax, [_currentTask]
    mov esp, [eax]
    ;
    ; Call tss_set_stack (kernelSS, kernelESP).
    ; This code will be needed later for user tasks.
    ;
    push dword ptr [eax+8]
    push dword ptr [eax+12]
    call tss_set_stack
    add esp, 8
    ;
    ; send EOI and restore context.
    ;
    pop gs
    pop fs
    pop es
    pop ds
interrupt_return:
    ;
    ; test if we need to call old ISR.
    ;
    mov eax, old_isr
    cmp eax, 0
    jne chain_interrupt
    ;
    ; if old_isr is null, send EOI and return.
    ;
    mov al,0x20
    out 0x20,al
    popad
    iretd
    ;
    ; if old_isr is valid, jump to it. This calls
    ; our PIT timer interrupt handler.
    ;
chain_interrupt:
    popad
    jmp old_isr
    }
}
</code></pre>
<p>The ISR is responsible for <strong>saving the current register context</strong> and <strong>saving the stack pointer of the current task</strong>. It then <strong>calls the scheduler</strong>, and <strong>restores the stack pointer from the current task</strong> and <strong>restores the register context that we saved before</strong>. Since everything is restored, the task and continue executing without problems when the ISR returns. The ISR appears more complicated then it actually is. Let's take a closer look at it in pieces. Like all of our other ISR's, the very first thing we do is save the current register state in order to preserve them on the stack. So the ISR begins like this:</p>
<pre><code class="lang-armasm">__declspec(naked) void _cdecl scheduler_isr () {
    _asm {
    cli
    pushad

    popad
    iretd
    }
}
</code></pre>
<p>Since we install the ISR on top of the ISR that was installed by the PIT, we need to be very careful here. This means that <strong>our scheduler_isr will be called with every clock tick</strong>. When we call <strong>setvect</strong> to install it, the <strong>PIT can fire before we have any tasks in the ready queue</strong>. When there are no tasks to run, we just want the ISR to return since there is nothing to do. You might also notice that we disable interrupts but never restore them. This is fine. Currently running tasks enable interrupts through the FLAGS register. Since the FLAGS register is preserved in all cases, when we issue IRETD, FLAGS.IF will enable when we return thereby re-enabling interrupts. Our ISR becomes,</p>
<pre><code class="lang-c">__declspec(naked) void _cdecl scheduler_isr () {
    _asm {
    cli
    pushad
    ;
    ; if no current task, just return.
    ;
    mov eax, [_currentTask]
    cmp eax, 0
    jz  interrupt_return

    ;
    ; &lt;actual ISR code here&gt;
    ;

interrupt_return:
    popad
    iretd
    }
}
</code></pre>
<p>Finally, we need to keep in mind that the PIT hardware is now calling <strong>scheduler_isr</strong>, so the PIT driver ISR is never being called. We want to <strong>chain the interrupt</strong>. This means, if there is an old ISR that was installed before us, we want to give it a chance to run. This is done by <strong>jumping</strong> (not calling) to it. When calling another ISR, we need to keep in mind that the ISR will either chain another interrupt or issue an <strong>End-Of-Interrupt (EOI)</strong> command to <strong>break the chain</strong>. When calling another ISR, we are still technically servicing an interrupt, so don't want to send EOI nor do we need an IRETD. However, when not calling another ISR and giving control back to the original process, we need both. So our ISR now becomes:</p>
<pre><code class="lang-armasm">__declspec(naked) void _cdecl scheduler_isr () {
    _asm {
    ;
    ; clear interrupts and save context.
    ;
    cli
    pushad
    ;
    ; if no current task, just return.
    ;
    mov eax, [_currentTask]
    cmp eax, 0
    jz  interrupt_return

    ;
    ; &lt;actual ISR code here&gt;
    ;

interrupt_return:
    ;
    ; test if we need to call old ISR.
    ;
    mov eax, old_isr
    cmp eax, 0
    jne chain_interrupt
    ;
    ; if old_isr is null, send EOI and return.
    ;
    mov al,0x20
    out 0x20,al
    popad
    iretd
    ;
    ; if old_isr is valid, jump to it. This calls
    ; our PIT timer interrupt handler.
    ;
chain_interrupt:
    popad
    jmp old_isr
    }
}
</code></pre>
<p>The actual body of the ISR that performs the actual tasking is the following part:</p>
<pre><code class="lang-armasm">    ; save selectors.
    ;
    push ds
    push es
    push fs
    push gs
    ;
    ; switch to kernel segments.
    ;
    mov ax, 0x10
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax
    ;
    ; save esp.
    ;
    mov eax, [_currentTask]
    mov [eax], esp
    ;
    ; call scheduler.
    ;
    call scheduler_tick
    ;
    ; restore esp.
    ;
    mov eax, [_currentTask]
    mov esp, [eax]
    ;
    ; Call tss_set_stack (kernelSS, kernelESP).
    ; This code will be needed later for user tasks.
    ;
    push dword ptr [eax+8]
    push dword ptr [eax+12]
    call tss_set_stack
    add esp, 8
    ;
    ; srestore context.
    ;
    pop gs
    pop fs
    pop es
    pop ds
</code></pre>
<p>It first pushes segment registers on the stack. (Recall that we did a PUSHAD before this. And the CPU pushed CS, EIP, and EFLAGS on the stack as well when the ISR was first called.) We store these on the stack so that we can <strong>save the current thread register context</strong>. <strong>The order that these registers are pushed on the stack matches the order that we use later in the stackFrame structure</strong>. We then set those segment registers to the kernel mode selectors we set up a long time ago from the <strong>Global Descriptor Table (GDT)</strong>. We do this because we are not making the assumption that the currently running task is a kernel mode task. <strong>If the task is a user mode task, DS, ES, FS, and GS would still be 0x23 rather then 0x10</strong>. We saved the original task selectors on the threads stack, so we can adjust them now. The CPU automatically sets SS and CS for us from the Task State Segment (TSS) when coming from a user mode task, so those would already be set appropriately. We will take a little more closer look at the stacks a little later. Finally, <strong>we save the current value of ESP to _currentTask-&gt;esp</strong>and call <strong>scheduler_tick</strong>.</p>
<p>_<strong>currentTask</strong>is assumed by the ISR to always be pointing to whatever the currently running task is. If the scheduler changes tasks, then that new task becomes the new “currently” running task. Even if its a new task, we just restore ESP to that new tasks *<strong>currentTask-&gt;esp</strong>field. Since we initially saved the register context on the new threads stack, we just pop them off back into their respective registers. We also call <strong>tss_set_stack</strong>that we implemented a long time ago. This is only useful if the task that we are returning to is a user mode task. What we do is set the new tasks kernel stack into TSS by updating it. For the upcoming demo, we will only be running kernel threads, each with only one kernel stack so this does not apply just yet. However, keep in mind that user level threads have two stacks rather then one, since the threads run in both user space and kernel space. We will be expanding on this farther in the next couple of chapters as we dive into address space management and user space.</p>
<p>So how do we switch tasks? Consider for a moment what would happen if that *<strong>currenTask</strong> pointer changes when the scheduler is called. Since the register context and stack pointer of this new task was saved the same way, by simply changing this pointer inside of the <strong>scheduler_tick</strong> function, the ISR would automatically load the new tasks register context and stack. And so, <strong>task switching is as simple as updating that pointer</strong>.</p>
<h3 id="switching-tasks">Switching Tasks</h3>
<p>So switching tasks just involves updating a pointer. With Round Robin scheduling, we can use a queue to store the running tasks. Since queues already operate in <strong>First-In-First-Out</strong> order, all we need to do is remove and reinsert the current task to push it back. This greatly simplifies the code.</p>
<pre><code class="lang-c">/* schedule next task. */
void dispatch () {
    /* We do Round Robin here, just remove and insert.
    Note _currentTask pointer always points to
    _currentThreadLocal. So just update _currentThreadLocal. */
    queue_remove();
    queue_insert(_currentThreadLocal);
    _currentThreadLocal = queue_get();
}

/* gets called for each clock tick. */
void scheduler_tick () {
    /* just run dispatcher. */
    dispatch();
}
</code></pre>
<p>That is all there is to it. The above implements <strong>Round Robin</strong> scheduling and swaps between the tasks after a certain <strong>quantum</strong> is up. Tasks are stored in the <strong>Ready Queue</strong> which was implemented earlier. This only leaves one more thing – task creation.</p>
<p>Although the above works for multiple threads, it will not work for threads belonging to different processes. The typical solution is to compare the current threads parent process with the new one. If they belong to the same process, then the dispatcher can simply return. If they belong to different processes, the dispatcher needs to invoke the VMM to switch to the new process address space. To keep the example code simple, we opted to avoid this for this chapter. However, we will be supporting it in the next chapter or two when we cover address space management in greater detail.</p>
<h3 id="task-creation">Task Creation</h3>
<p>Let's say that our <strong>schedule</strong> function updates the *<strong>currentTask</strong> pointer to a different task. So when this function returns back to the ISR, the ISR will set the stack and register context from this new task before issuing IRETD. This works well, but only if the task already has a stack and register context on the stack.</p>
<p>So we need to set it up when creating the task in the first time. So we set up a basic stack frame and set the task <strong>esp</strong> and <strong>eip</strong> to the stack and <strong>entry</strong> point function. The stack frame must be one that is expected by our ISR. When we return back to the ISR, it will POP GS, POP FS, POP ES, POP DS first, then does a PUSHA followed by an IRETD. PUSHA pops EAX, EBX, ECX, EDX, ESI, EDI, ESP, and EBP. And IRETD pops EIP, CS, and FLAGS. So this must be our initial stack frame when the task is created.</p>
<pre><code class="lang-c">typedef struct _stackFrame {
  uint32_t gs;
  uint32_t fs;
  uint32_t es;
  uint32_t ds;
  uint32_t eax;
  uint32_t ebx;
  uint32_t ecx;
  uint32_t edx;
  uint32_t esi;
  uint32_t edi;
  uint32_t esp;
  uint32_t ebp;
  uint32_t eip;
  uint32_t cs;
  uint32_t flags;
}stackFrame;

task  task_create (uint32_t entry, uint32_t esp) {
  thread t;
  stackFrame* frame = ((stackFrame*) esp);
  frame-&gt;flags = 0x202;
  frame-&gt;cs    = 8;
  frame-&gt;eip   = (uint32_t)entry;
  frame-&gt;ebp   = 0;
  frame-&gt;esp   = 0;
  frame-&gt;edi   = 0;
  frame-&gt;esi   = 0;
  frame-&gt;edx   = 0;
  frame-&gt;ecx   = 0;
  frame-&gt;ebx   = 0;
  frame-&gt;eax   = 0;
  frame-&gt;ds    = 0x10;
  frame-&gt;es    = 0x10;
  frame-&gt;fs    = 0x10;
  frame-&gt;gs    = 0x10;
  t.esp = (uint32_t) frame;
  t.ss = 0x10;
  return t;
}
</code></pre>
<p>This works for most tasks, except one – the <em><strong>initial task</strong></em>. The ISR we created will only work if the currently executing code is within a task. It is yet another chicken and egg problem. To get around this, we need to create a special task object and execute it when we are ready to start multitasking.</p>
<pre><code class="lang-c">static thread _idleTask;
void task_execute(thread t) {
  _asm{
    mov esp, t.esp
    pop gs
    pop fs
    pop es
    pop ds
    popad
    iretd
  }
}

/* initialize scheduler. */
void scheduler_initialize(void) {

    /* clear ready queue. */
    clear_queue();

    /* clear process list. */
    init_process_list();

    /* create idle thread and add it. */
    _idleThread = thread_create(idle_task, (uint32_t) create_kernel_stack(), true);

    /* set current thread to idle task and add it. */
    _currentThreadLocal = _idleThread;
    _currentTask        = &amp;_currentThreadLocal;
    queue_insert(_idleThread);

    /* register isr */
    old_isr = getvect(32);
    setvect (32, scheduler_isr, 0x80);
}

/* idle task. */
void idle_task() {
  while(1) _asm pause;
}
</code></pre>
<p>The above puts everything together. It creates an idle task, adds it to the queue, installs the ISR, and executes the initial task. When the initial task executes, the ISR will be called whenever the PIT fires to call the scheduler to update the current task if needed.</p>
<h2 id="introduction-to-mp">Introduction to MP</h2>
<p>This is a <em>very</em> brief introduction to the <strong>Multi-Processor (MP) Specification</strong> that is designed to provide a standard interface for starting up the other processors and <strong>Inter-Processor Interrupts (IPI)</strong>. We consider this an advanced topic since it can quickly escalate the difficulty of concurrent programming. Our scheduler only executes one task at a time, however with MP, we can implement a low level scheduler responsible for scheduling independent CPU's for the tasks and can achieve running multiple tasks at the same time. So what we are presenting here is just a very brief introduction – for anyone wanting to dive more into the MP standard, we recommend checking out the MP specification. Your system must already support the IOAPIC, LAPIC, and ICI which are used by MP.</p>
<p>There is <strong>symmetric multiprocessing (SMP)</strong> and <strong>asymmetric multiprocessing (ASP)</strong>. In SMP, all of the processors are of the same type whereas in ASP they are not. Most systems only support SMP given that ASP systems are very rare in desktop systems. However, the MP standard is applicable to both and gives itself some room for extendability so it can adopt to more diverse machine types and farther allows the operating systems to adopt and configure itself for different types of systems.</p>
<p>When the system first starts up, the hardware selects a <strong>Boot-Strap Processor (BSP)</strong> to act as the sole processor to start up. The BSP is the first processor to start up and must be the last processor to shut down. The operating system may send a <strong>STARTUP IPI</strong> from the BSP to another <strong>Application Processor (AP)</strong> to start it. Other AP's can be started by either the BSP or another AP. The <strong>STARTUP IPI</strong> (and <strong>INIT IPI</strong>) is what the operating system sends to wake the other processors.</p>
<p>The operating system must first search for the floating <strong>MP Floating Pointer</strong> structure in order to detect if the system supports MP. The structure contains the <strong>physical address</strong> of the <strong>MP Configuration Table</strong>. The configuration table is <strong>read only</strong>. It stores the <strong>memory mapped address of the Local APIC (LAPC), Processor entries (including the processor LAPIC ID), IOAPIC entries (including IOAPIC base memory mapped address), Buses, and interrupt configuration entries</strong>. The operating system must remember the LAPIC ID of the BSP to make sure it is the last one to shut down.</p>
<p>To wake another AP, all we need to do is send a <strong>INIT IPI</strong> through the BSP LAPIC or another AP LAPIC. The memory mapped registers for the LAPIC's are stored in the processor information in the MP configuration table. We then need to send an <strong>STARTUP IPI</strong> to that AP to start executing. That's really all there is to it. The INIT IPI causes the AP to <strong>reset</strong>. The STARTUP IPI causes it to start executing at the location you tell it to in real mode. Operating systems must provide a real mode stub routine for configuring the API's in protected or long modes just as you did for the BSP.</p>
<p>So that is pretty much all we wanted to cover in this brief introduction to multiprocessor systems. Starting up other processors (or processor cores0 is fairly simple and we encourage experimenting with SMP after implementing your scheduler. We may cover MP in more detail in a later tutorial after covering the APIC. We just wanted to give a little overview and direction for those interested in it now.</p>
<h2 id="demo">Demo</h2>
<p><a href="../../resources/OSDev_tools/Demo25.zip">Download Demo</a></p>
<p>Most of the new code has been covered in the above text, we are just preparing the initial release. Assuming no problems arise during stress tests and final integration, the demo should be released sometime within the next week or two.</p>
<p><img src="../../resources/images/demo25.png" alt="Demo running in 800x600x32 mode executing three tasks"><br>
Demo running in 800x600x32 mode executing three tasks</p>
<p>This is our first real graphical demo. The demo runs three tasks concurrently; each task cycles through a select color in video memory while running to visually show that they are executing. We opted to have a graphical demo rather then text based since we believe we can have it more visually appealing yet still simple to do. It is alright if you did not read through the graphics series yet, we will discuss things here.</p>
<h3 id="bochs-graphics-adapter-bga">Bochs Graphics Adapter (BGA)</h3>
<p>To keep the code as simple as possible so we can focus on the primary topic of the chapter, we opted to use BGA under the assumption that the system is configured for ISA. <em><strong>This code is Bochs specific</strong></em> and will not work on real systems. Real systems would require scanning the PCI bus infrastructure which may be a topic in a more advanced chapter.</p>
<pre><code class="lang-c">#define VBE_DISPI_IOPORT_INDEX          0x01CE
#define VBE_DISPI_IOPORT_DATA           0x01CF
#define VBE_DISPI_INDEX_XRES            0x1
#define VBE_DISPI_INDEX_YRES            0x2
#define VBE_DISPI_INDEX_BPP             0x3
#define VBE_DISPI_INDEX_ENABLE          0x4
#define VBE_DISPI_DISABLED              0x00
#define VBE_DISPI_ENABLED               0x01
#define VBE_DISPI_LFB_ENABLED           0x40

void VbeBochsWrite(uint16_t index, uint16_t value) {
   outportw (VBE_DISPI_IOPORT_INDEX, index);
   outportw (VBE_DISPI_IOPORT_DATA, value);
}

void VbeBochsSetMode (uint16_t xres, uint16_t yres, uint16_t bpp) {
   VbeBochsWrite (VBE_DISPI_INDEX_ENABLE, VBE_DISPI_DISABLED);
   VbeBochsWrite (VBE_DISPI_INDEX_XRES, xres);
   VbeBochsWrite (VBE_DISPI_INDEX_YRES, yres);
   VbeBochsWrite (VBE_DISPI_INDEX_BPP, bpp);
   VbeBochsWrite (VBE_DISPI_INDEX_ENABLE, VBE_DISPI_ENABLED | VBE_DISPI_LFB_ENABLED);
}
</code></pre>
<p>To set the video mode just involves calling <strong>VbeBochsSetMode</strong>. We use <strong>800x600x32</strong>in our example since it appears to be well supported. **The Linear Frame Buffer (LFB)**under ISA is at the predefined location <strong>0xe0000000</strong>. However, because we have paging enabled, we need to map the LFB into our virtual address space to use it. We will map it to 0x200000 virtual for the demo. The mapping is done by calculating the size of the LFB in number of pages, and mapping each page by calling our VMM.</p>
<pre><code class="lang-c">void* VbeBochsMapLFB () {

/* BGA LFB is at LFB_PHYSICAL for ISA systems. */
#define LFB_PHYSICAL 0xE0000000
#define LFB_VIRTUAL  0x200000

  /* map LFB into current process address space. */
  int pfcount = WIDTH*HEIGHT*BYTES_PER_PIXEL/4096;
  int c;
  for (c = 0;c &lt;= pfcount; c++)
    vmmngr_mapPhysicalAddress (vmmngr_get_directory(),LFB_VIRTUAL + c * 0x1000,LFB_PHYSICAL + c * 0x1000, 3);

  /* return pointer to LFB. */
  return (void*) LFB_VIRTUAL;
}
</code></pre>
<p>With the above function, we can now draw to the LFB by writing to 0x200000. To clean up any possible garbage on the display, we clear it next. Since we need to draw a lot of pixels, we try to optimize the function for 32 bit modes. This function makes the screen white.</p>
<pre><code class="lang-c">void fillScreen32 () {
  uint32_t* lfb = (uint32_t*) LFB_VIRTUAL;
  for (uint32_t c=0; c&lt;WIDTH*HEIGHT; c++)
    lfb[c] = 0xffffffff;
}
</code></pre>
<p>In 32 Bits Per Pixel modes, the pixel colors are composed of 8 bits for red, 8 bits for green, and 8 bits for blue. The high 8 bits are ignored for our purposes but is typically used as a transparency value. We use three separate tasks to render the three rectangles and cycle through the intensity of the three colors. Since we are going to render to different locations on display, we won't have to worry about concurrency problems here. Although display memory is shared, each task will render to separate parts.</p>
<pre><code class="lang-c">void rect32 (int x, int y, int w, int h, int col) {
  uint32_t* lfb = (uint32_t*) LFB_VIRTUAL;
  for (uint32_t k = 0; k &lt; h; k++)
    for (uint32_t j = 0; j &lt; w; j++)
      lfb[(j+x) + (k+y) * WIDTH] = col;
}
</code></pre>
<pre><code class="lang-c">void kthread_1() {
  int col = 0;
  bool dir = true;
  while(1) {
    rect32(200,250,100,100,col &lt;&lt; 16);
    if (dir){
      if (col++ == 0xfe)
        dir=false;
    }else
      if (col-- == 1)
        dir=true;
 }
}
</code></pre>
<pre><code class="lang-c">void kthread_2 () {
  int col = 0;
  bool dir = true;
  while(1) {
    rect32(350,250,100,100,col &lt;&lt; 8);
    if (dir){
      if (col++ == 0xfe)
        dir=false;
    }else
      if (col-- == 1)
        dir=true;
  }
}
</code></pre>
<pre><code class="lang-c">void kthread_3 () {
  int col = 0;
  bool dir = true;
  while(1) {
    rect32(500,250,100,100,col);
    if (dir) {
      if (col++ == 0xfe)
        dir=false;
    }else
      if (col-- == 1)
        dir=true;
  }
}
</code></pre>
<h3 id="thread-stacks">Thread Stacks</h3>
<p>Typically a thread has two separate stacks. One for when executing in user mode, and another for when executing in kernel mode. Recall that when a thread is executing in user mode, the CPU switches to a kernel stack by getting the <strong>esp0</strong>and <strong>ss0</strong>fields of the <strong>Task State Segment (TSS)</strong>. The scheduler is responsible for updating the TSS to the new threads kernel mode stack. However, for chapter 25, since all threads run in kernel space, the TSS will never be referenced. In other words, <strong>the threads in chapter 25 only have one stack – a kernel mode stack</strong>.</p>
<p>We will be supporting user mode threads within the next two chapters when we cover address space management. We will use our future address space allocator to reserve stack space in user space for each user mode thread. That means <strong>threads will have both a user mode and kernel mode stack</strong>.</p>
<p>The thread uses the kernel mode stack when executing code with **Current Privilege Level (CPL)**of 0. The CPU automatically loads this if the CPL is less then the **Requested Privilege Level (RPL)**from the <strong>TSS</strong>. In other words, lets say that our user mode thread is running and the PIT fires. The CPU will then set <strong>SS=TSS.ss0</strong>and <strong>ESP=TSS.esp0</strong>. It will then <strong>push the return CS and IP on this new stack</strong>and call the ISR. When the ISR is done, it executes <strong>IRET</strong>to return back to the user mode code and stack.</p>
<p>This is why user level threads must have, at a minimum, <em><strong>two</strong></em>separate stacks. The first stack must be mapped in kernel space and the other must be mapped in user space so the program can access it while executing. Kernel level threads only need <em><strong>one</strong></em>stack.</p>
<p>Since we don't have an address space allocator, we cannot nicely allocate user mode stacks just yet, so cannot support user level threads (without hacks.) And since we don't have a proper kernel mode allocator yet, we can't nicely support allocation of kernel level stacks either. These will be the topics for the next chapter or two.</p>
<p>So what we decided to do for chapter 25 was to reserve space in kernel memory and allocate each 4k block as its own stack.</p>
<pre><code class="lang-c">void* create_kernel_stack() {

    physical_addr       p;
    virtual_addr        location;
    void*               ret;

    /* we are reserving this area for 4k kernel stacks. */
#define KERNEL_STACK_ALLOC_BASE 0xe0000000

    /* allocate a 4k frame for the stack. */
    p = (physical_addr) pmmngr_alloc_block();
    if (!p) return 0;

    /* next free 4k memory block. */
    location = KERNEL_STACK_ALLOC_BASE + _kernel_stack_index * PAGE_SIZE;

    /* map it into kernel space. */
    vmmngr_mapPhysicalAddress (vmmngr_get_directory(), location, p, 3);

    /* we are returning top of stack. */
    ret = (void*) (location + PAGE_SIZE);

    /* prepare to allocate next 4k if we get called again. */
    _kernel_stack_index++;

    /* and return top of stack. */
    return ret;
}
</code></pre>
<h3 id="back-to-sleep">Back to Sleep</h3>
<p>You might recall that we implemented a very basic <strong>sleep</strong> function that we needed in order to delay the read operation of the floppy device. Our implementation simply went into a <strong>busy loop</strong> in order to waste some time. Now we can adopt it for the threading system.</p>
<p>The basic idea is that <strong>sleep</strong> should <strong>pause</strong> the thread that called the function. This means we need to adjust the current thread state from READY to BLOCK and force a task switch. The scheduler then needs to keep track of blocked threads to handle them properly. This is typically done via <strong>Signals</strong> from other operating system components. For example, if a thread is waiting for a device to be ready, it may block. Now the system needs to wait until that thread receives a signal from the driver. Until then, the scheduler should jump to executing other threads. To keep the demo relatively simple, we opted to do things a little differently.</p>
<p>All we need to do is change the state of the currently running program and force a task switch (by calling the ISR directly via <strong>int 33</strong>.) The scheduler would contain the logic code for checking blocked threads while selecting new threads to run. If the next thread is blocked, we decrement its sleep time delta and awake the thread is the sleep time delta reaches zero.</p>
<p>Although we do not use sleep in this demo, the disk driver code relies on it. So now the thread attempting to read from the disk device can properly sleep.</p>
<h3 id="main-program">Main Program</h3>
<p>Finally, we will take a look at the main program. In the demo for Chapter 25, we moved the stack into kernel space and readjust it after making a static copy of the boot parameter block that was passed from the boot loader. We then use the services discussed above to set the video mode, initialize the scheduler, and create and add three threads to the ready queue. Since the threads run in kernel space, they only have a kernel stack allocated to them, which we allocate calling <strong>create_kernel_stack</strong>.</p>
<p>We have also completely rewritten the process creation and management code from Chapter 24 to be compatible with the thread system created in Chapter 25. However, it will not be completed until we support the allocation of user mode stacks which we will do in the upcoming chapters.</p>
<pre><code class="lang-c">void _cdecl kmain (multiboot_info* bootinfo) {

    /* store kernel size and copy bootinfo. */
    _asm mov        word ptr [kernelSize], dx
    memcpy(&amp;_bootinfo, bootinfo, sizeof(multiboot_info));

    /* adjust stack. */
    _asm lea esp, dword ptr [_kernel_stack+8096]
    init (&amp;_bootinfo);

    /* set video mode and map framebuffer. */
    VbeBochsSetMode(WIDTH,HEIGHT,BPP);
    VbeBochsMapLFB();
    fillScreen32 ();

    /* init scheduler. */
    scheduler_initialize ();

    /* create kernel threads. */
    queue_insert (thread_create(kthread_1, (uint32_t) create_kernel_stack(),true));
    queue_insert (thread_create(kthread_2, (uint32_t) create_kernel_stack(),true));
    queue_insert (thread_create(kthread_3, (uint32_t) create_kernel_stack(),true));

    /* execute idle thread. */
    execute_idle();

    /* this should never get executed. */
    for (;;) _asm {cli
            hlt};
}
</code></pre>
<h2 id="conclusion">Conclusion</h2>
<p>In this chapter we looked at scheduling algorithms, a brief overview of SMP, concurrent programming, and implemented a working preemptive Round Robin scheduler. We have also went through a small introduction to high resolution video modes using Bochs Graphics Adapter (BDA), state management, and an introduction to several IPC techniques.</p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/enygmator/BrokenThorn-OS-Dev-Series/blob/master/docfx_base/articles/61_unorganised_tutorial/T25.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            <span><strong>Project (v2.0)</strong> created by <a href="https://github.com/enygmator/">@enygmator</a><br>Tutorial authored by <a href="http://www.brokenthorn.com/">BrokenThorn Entertainment Co.</a><br>Generated by <strong>DocFX v2.56.1</strong></span>
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
